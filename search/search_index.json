{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yelmo Welcome to Yelmo , an easy to use continental ice sheet model. Yelmo is a 3D thermomechanical ice sheet model that simulates continental scale ice sheets. The ice dynamics can be treated via the Shallow Ice Approximation (SIA) for land-based ice driven by deformation, the Shallow Shelf Approximation (SSA) for faster moving ice streams and ice shelves and a hybrid configuration that heuristically combines the two approximations into one solution. Yelmo has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain. A description of Yelmo along with validation tests has been published here: Robinson et al., 2019, in prep. The Yelmo code repository can be found here: https://github.com/palma-ice/yelmo General model structure - classes and usage yelmo_class The Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing various parameters, variables or sets of module variables. type yelmo_class type(yelmo_param_class) :: par ! General domain parameters type(ygrid_class) :: grd ! Grid definition type(ytopo_class) :: tpo ! Topography variables type(ydyn_class) :: dyn ! Dynamics variables type(ymat_class) :: mat ! Material variables type(ytherm_class) :: thrm ! Thermodynamics variables type(ybound_class) :: bnd ! Boundary variables to drive model type(ydata_class) :: dta ! Data variables for comparison type(yregions_class) :: reg ! Regionally aggregated variables end type Likewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography: type ytopo_class type(ytopo_param_class) :: par ! Parameters type(ytopo_state_class) :: now ! Variables end type Submodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as all variables that define the state of the domain being modeled. Example model domain intialization The below code snippet shows an example of how to initialize an instance of Yelmo inside of a program, run the model forward in time and then terminate the instance. ! === Initialize ice sheet model ===== ! General initialization of yelmo constants (used globally, only once per program) call yelmo_global_init(path_const) ! Initialize Yelmo objects (multiple yelmo objects can be initialized if needed) ! In this case `yelmo1` is the Yelmo object to initialize and `path_par` is the ! path to the parameter file to load for the configuration information. This ! command will also initialize the domain grid and load initial topographic ! variables. call yelmo_init(yelmo1,filename=path_par,grid_def=\"file\",time=time_init) ! === Load initial boundary conditions for current time and yelmo state ===== ! These variables can be loaded from a file, or passed from another ! component being simulated. Yelmo does not care about the source, ! it only needs all variables in the `bnd` class to be populated. ! ybound: z_bed, z_sl, H_sed, H_w, smb, T_srf, bmb_shlf, T_shlf, Q_geo yelmo1%bnd%z_bed = [2D array] yelmo1%bnd%z_sl = [2D array] yelmo1%bnd%H_sed = [2D array] yelmo1%bnd%H_w = [2D array] yelmo1%bnd%smb = [2D array] yelmo1%bnd%T_srf = [2D array] yelmo1%bnd%bmb_shlf = [2D array] yelmo1%bnd%T_shlf = [2D array] yelmo1%bnd%Q_geo = [2D array] ! Print summary of initial boundary conditions call yelmo_print_bound(yelmo1%bnd) ! Next, initialize the state variables (dyn,therm,mat) ! (in this case, initialize temps with robin method) call yelmo_init_state(yelmo1,path_par,time=time_init,thrm_method=\"robin\") ! Run yelmo for eg 100.0 years with constant boundary conditions and topo ! to equilibrate thermodynamics and dynamics ! (impose a constant, small dt=1yr to reduce possibility for instabilities) call yelmo_update_equil(yelmo1,time,time_tot=100.0,topo_fixed=.FALSE.,dt=1.0) ! == YELMO INITIALIZATION COMPLETE == ! Note: the above routines `yelmo_init_state` and `yelmo_update_equil` ! are optional, if the user prefers another way to initialize the state variables. ! == Start time looping and run the model == ! Advance timesteps do n = 1, ntot ! Get current time time = time_init + n*dt ! Update the Yelmo ice sheet call yelmo_update(yelmo1,time) ! Here you may be updating `yelmo1%bnd` variables to drive the model transiently. end do ! == Finalize Yelmo instance == call yelmo_end(yelmo1,time=time) That's it! See Getting started to see how to get the code, compile a test program and run simulations.","title":"Home"},{"location":"#yelmo","text":"Welcome to Yelmo , an easy to use continental ice sheet model. Yelmo is a 3D thermomechanical ice sheet model that simulates continental scale ice sheets. The ice dynamics can be treated via the Shallow Ice Approximation (SIA) for land-based ice driven by deformation, the Shallow Shelf Approximation (SSA) for faster moving ice streams and ice shelves and a hybrid configuration that heuristically combines the two approximations into one solution. Yelmo has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain. A description of Yelmo along with validation tests has been published here: Robinson et al., 2019, in prep. The Yelmo code repository can be found here: https://github.com/palma-ice/yelmo","title":"Yelmo"},{"location":"#general-model-structure-classes-and-usage","text":"","title":"General model structure - classes and usage"},{"location":"#yelmo_class","text":"The Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing various parameters, variables or sets of module variables. type yelmo_class type(yelmo_param_class) :: par ! General domain parameters type(ygrid_class) :: grd ! Grid definition type(ytopo_class) :: tpo ! Topography variables type(ydyn_class) :: dyn ! Dynamics variables type(ymat_class) :: mat ! Material variables type(ytherm_class) :: thrm ! Thermodynamics variables type(ybound_class) :: bnd ! Boundary variables to drive model type(ydata_class) :: dta ! Data variables for comparison type(yregions_class) :: reg ! Regionally aggregated variables end type Likewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography: type ytopo_class type(ytopo_param_class) :: par ! Parameters type(ytopo_state_class) :: now ! Variables end type Submodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as all variables that define the state of the domain being modeled.","title":"yelmo_class"},{"location":"#example-model-domain-intialization","text":"The below code snippet shows an example of how to initialize an instance of Yelmo inside of a program, run the model forward in time and then terminate the instance. ! === Initialize ice sheet model ===== ! General initialization of yelmo constants (used globally, only once per program) call yelmo_global_init(path_const) ! Initialize Yelmo objects (multiple yelmo objects can be initialized if needed) ! In this case `yelmo1` is the Yelmo object to initialize and `path_par` is the ! path to the parameter file to load for the configuration information. This ! command will also initialize the domain grid and load initial topographic ! variables. call yelmo_init(yelmo1,filename=path_par,grid_def=\"file\",time=time_init) ! === Load initial boundary conditions for current time and yelmo state ===== ! These variables can be loaded from a file, or passed from another ! component being simulated. Yelmo does not care about the source, ! it only needs all variables in the `bnd` class to be populated. ! ybound: z_bed, z_sl, H_sed, H_w, smb, T_srf, bmb_shlf, T_shlf, Q_geo yelmo1%bnd%z_bed = [2D array] yelmo1%bnd%z_sl = [2D array] yelmo1%bnd%H_sed = [2D array] yelmo1%bnd%H_w = [2D array] yelmo1%bnd%smb = [2D array] yelmo1%bnd%T_srf = [2D array] yelmo1%bnd%bmb_shlf = [2D array] yelmo1%bnd%T_shlf = [2D array] yelmo1%bnd%Q_geo = [2D array] ! Print summary of initial boundary conditions call yelmo_print_bound(yelmo1%bnd) ! Next, initialize the state variables (dyn,therm,mat) ! (in this case, initialize temps with robin method) call yelmo_init_state(yelmo1,path_par,time=time_init,thrm_method=\"robin\") ! Run yelmo for eg 100.0 years with constant boundary conditions and topo ! to equilibrate thermodynamics and dynamics ! (impose a constant, small dt=1yr to reduce possibility for instabilities) call yelmo_update_equil(yelmo1,time,time_tot=100.0,topo_fixed=.FALSE.,dt=1.0) ! == YELMO INITIALIZATION COMPLETE == ! Note: the above routines `yelmo_init_state` and `yelmo_update_equil` ! are optional, if the user prefers another way to initialize the state variables. ! == Start time looping and run the model == ! Advance timesteps do n = 1, ntot ! Get current time time = time_init + n*dt ! Update the Yelmo ice sheet call yelmo_update(yelmo1,time) ! Here you may be updating `yelmo1%bnd` variables to drive the model transiently. end do ! == Finalize Yelmo instance == call yelmo_end(yelmo1,time=time) That's it! See Getting started to see how to get the code, compile a test program and run simulations.","title":"Example model domain intialization"},{"location":"dependencies/","text":"Dependencies Yelmo is dependent on the following libraries: NetCDF Library of Iterative Solvers for Linear Systems Installation tips can be found below. Installing NetCDF (preferably version 4.0 or higher) The NetCDF library is typically available with different distributions (Linux, Mac, etc). Along with installing libnetcdf , it will be necessary to install the package libnetcdf-dev . Installing the NetCDF viewing program ncview is also recommended. If you want to install NetCDF from source, then you must install both the netcdf-c and subsequently netcdf-fortran libraries. The source code and installation instructions are available from the Unidata website: https://www.unidata.ucar.edu/software/netcdf/docs/getting_and_building_netcdf.html Installing LIS Download the LIS source: https://www.ssisc.org/lis/ Configure the package (where is the desired installation location), and install it in the location of your choice (below defined as $LISROOT ). Also, make sure to enable the Fortran90 interface: cd lis-2.0.18 ./configure --prefix=$LISROOT --enable-f90 make make install make install check Note: make sure to set the environment variables CC and FC , in order to set a specific compiler, for example for gcc/gfortran use the following configure command: CC=gcc FC=gfortran ./configure --prefix=$LISROOT --enable-f90 Add LIS path to the LD_LIBRARY_PATH in .bash_profile, .bashrc or .bash_aliases: # lis library paths LD_LIBRARY_PATH=$LISROOT/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH That's it. LIS should now be available to use with Yelmo.","title":"Dependencies"},{"location":"dependencies/#dependencies","text":"Yelmo is dependent on the following libraries: NetCDF Library of Iterative Solvers for Linear Systems Installation tips can be found below.","title":"Dependencies"},{"location":"dependencies/#installing-netcdf-preferably-version-40-or-higher","text":"The NetCDF library is typically available with different distributions (Linux, Mac, etc). Along with installing libnetcdf , it will be necessary to install the package libnetcdf-dev . Installing the NetCDF viewing program ncview is also recommended. If you want to install NetCDF from source, then you must install both the netcdf-c and subsequently netcdf-fortran libraries. The source code and installation instructions are available from the Unidata website: https://www.unidata.ucar.edu/software/netcdf/docs/getting_and_building_netcdf.html","title":"Installing NetCDF (preferably version 4.0 or higher)"},{"location":"dependencies/#installing-lis","text":"Download the LIS source: https://www.ssisc.org/lis/ Configure the package (where is the desired installation location), and install it in the location of your choice (below defined as $LISROOT ). Also, make sure to enable the Fortran90 interface: cd lis-2.0.18 ./configure --prefix=$LISROOT --enable-f90 make make install make install check Note: make sure to set the environment variables CC and FC , in order to set a specific compiler, for example for gcc/gfortran use the following configure command: CC=gcc FC=gfortran ./configure --prefix=$LISROOT --enable-f90 Add LIS path to the LD_LIBRARY_PATH in .bash_profile, .bashrc or .bash_aliases: # lis library paths LD_LIBRARY_PATH=$LISROOT/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH That's it. LIS should now be available to use with Yelmo.","title":"Installing LIS"},{"location":"example-programs/","text":"Example programs The Yelmo base code provides a static library interface that can be used in other programs, as well as a couple of stand-alone programs for running certain benchmarks. Here we provide more examples of how to use Yelmo: 1) Program template to connect with other models/components. 2) Stand-alone ice sheet with full boundary forcing. In both cases, it is necessary to download the Yelmo repository separately, as well as compile the Yelmo static library (see Getting started ). Program template This is a minimalistic setup that allows you to run Yelmo with no dependencies and a straightforward Makefile. This template can be used to design a new stand-alone Yelmo experiment, or to provide guidance when adding Yelmo to another program. Clone the repository from https://github.com/palma-ice/yelmot Stand-alone ice sheet with full boundary forcing (yelmox) This setup is suitable for glacial-cycle simulations, future simulations or any other typical (realistic) ice-sheet model simulation. Clone the repository from https://github.com/palma-ice/yelmox","title":"Examples"},{"location":"example-programs/#example-programs","text":"The Yelmo base code provides a static library interface that can be used in other programs, as well as a couple of stand-alone programs for running certain benchmarks. Here we provide more examples of how to use Yelmo: 1) Program template to connect with other models/components. 2) Stand-alone ice sheet with full boundary forcing. In both cases, it is necessary to download the Yelmo repository separately, as well as compile the Yelmo static library (see Getting started ).","title":"Example programs"},{"location":"example-programs/#program-template","text":"This is a minimalistic setup that allows you to run Yelmo with no dependencies and a straightforward Makefile. This template can be used to design a new stand-alone Yelmo experiment, or to provide guidance when adding Yelmo to another program. Clone the repository from https://github.com/palma-ice/yelmot","title":"Program template"},{"location":"example-programs/#stand-alone-ice-sheet-with-full-boundary-forcing-yelmox","text":"This setup is suitable for glacial-cycle simulations, future simulations or any other typical (realistic) ice-sheet model simulation. Clone the repository from https://github.com/palma-ice/yelmox","title":"Stand-alone ice sheet with full boundary forcing (yelmox)"},{"location":"getting-started/","text":"Getting started This file describes the basic information and steps needed to get Yelmo running. Dependencies NetCDF library (preferably version 4.0 or higher) LIS: Library of Iterative Solvers for Linear Systems See: Dependencies OPTIONAL: - Python 3.x, which is only needed for automatic configuration of the Makefile and the use of the script run_yelmo.py for job preparation and submission. Directory structure config/ Configuration files for compilation on different systems. input/ Location of any input data needed by the model. libs/ Auxiliary libraries nesecessary for running the model. libyelmo/ Folder containing all compiled files in a standard way with lib/, include/ and bin/ folders. output/ Default location for model output. par/ Default parameter files that manage the model configuration. src/ Source code for Yelmo. tests/ Source code and analysis scripts for specific model benchmarks and tests. Usage Yelmo is hosted in a git repository. Follow the steps below to obtain the code, compile it and run a test simulation. 1. Get the code. Clone the repository from https://github.com/palma-ice/yelmo : git clone git@github.com:palma-ice/yelmo.git $YELMOROOT cd $YELMOROOT where $YELMOROOT is the installation directory. If you plan to make changes to the code, it is wise to check out a new branch: git checkout -b user-dev You should now be working on the branch user-dev . 2. Create the system-specific Makefile. To compile Yelmo, you need to generate a Makefile that is appropriate for your system. In the folder config , you need to specify a configuration file that defines the compiler and flags, including definition of the paths to the NetCDF and LIS libraries. You can use another file in the config folder as a template, e.g., cd config cp pik_ifort myhost_mycompiler then modify the file myhost_mycompiler to match your paths. Back in $YELMOROOT , you can then generate your Makefile with the provided python configuration script: cd $YELMOROOT python config.py config/myhost_mycompiler The result should be a Makefile in $YELMOROOT that is ready for use. 3. Compile the code. Now you are ready to compile Yelmo as a static library: make clean # This step is very important to avoid errors!! make yelmo-static [debug=1] This will compile all of the Yelmo modules and libraries (as defined in config/Makefile_yelmo.mk ), and link them in a static library. All compiled files can be found in the folder libyelmo/ . Once the static library has been compiled, it can be used inside of external Fortran programs and modules via the statement use yelmo . To include/link yelmo-static during compilation of another program, its location must be defined: INC_YELMO = -I${YELMOROOT}/include LIB_YELMO = -L${YELMOROOT}/include -lyelmo Alternatively, several test programs exist in the folder tests/ to run Yelmo as a stand-alone ice sheet. For example, it's possible to run different EISMINT benchmarks, MISMIP benchmarks and the ISIMIP6 INITMIP simulation for Greenland, respectively: make benchmarks # compiles the program `libyelmo/bin/yelmo_benchmarks.x` make mismip # compiles the program `libyelmo/bin/yelmo_mismip.x` make initmip # compiles the program `libyelmo/bin/yelmo_initmip.x` The Makefile additionally allows you to specify debugging compiler flags with the option debug=1 , in case you need to debug the code (e.g., make benchmarks debug=1 ). Using this option, the code will run much slower, so this option is not recommended unless necessary. 4. Run the model. Once an executable has been created, you can run the model. This can be achieved via the included Python job submission script run_yelmo.py . The following steps are carried out via the script: The output directory is created. The executable is copied to the output directory The relevant parameter files are copied to the output directory. Links to the input data paths ( input and ice_data ) are created in the output directory. (Note ice_data is typically linked to an external data repository, and is not necessary.) The executable is run from the output directory, either as a background process or it is submitted to the queue (the script currently supports qsubmit and sbatch commands). To run a benchmark simulation, for example, use the following command: python run_yelmo.py -r -e benchmarks output/test par/yelmo_EISMINT.nml where the option -r implies that the model should be run as a background process. If this is omitted, then the output directory will be populated, but no executable will be run, while -s instead will submit the simulation to cluster queue system instead of running in the background. The option -e lets you specify the executable. For some standard cases, shortcuts have been created: benchmarks = libyelmo/bin/yelmo_benchmarks.x mismip = libyelmo/bin/yemo_mismip.x initmip = libyelmo/bin/yelmo_initmip.x The last two mandatory arguments are always the output/run directory and the parameter file to be used for this simulation. In the case of the above simulation, the output directory is defined as output/test , where all model parameters (loaded from the file par/yelmo_EISMINT.nml ) and model output can be found.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"This file describes the basic information and steps needed to get Yelmo running.","title":"Getting started"},{"location":"getting-started/#dependencies","text":"NetCDF library (preferably version 4.0 or higher) LIS: Library of Iterative Solvers for Linear Systems See: Dependencies OPTIONAL: - Python 3.x, which is only needed for automatic configuration of the Makefile and the use of the script run_yelmo.py for job preparation and submission.","title":"Dependencies"},{"location":"getting-started/#directory-structure","text":"config/ Configuration files for compilation on different systems. input/ Location of any input data needed by the model. libs/ Auxiliary libraries nesecessary for running the model. libyelmo/ Folder containing all compiled files in a standard way with lib/, include/ and bin/ folders. output/ Default location for model output. par/ Default parameter files that manage the model configuration. src/ Source code for Yelmo. tests/ Source code and analysis scripts for specific model benchmarks and tests.","title":"Directory structure"},{"location":"getting-started/#usage","text":"Yelmo is hosted in a git repository. Follow the steps below to obtain the code, compile it and run a test simulation.","title":"Usage"},{"location":"getting-started/#1-get-the-code","text":"Clone the repository from https://github.com/palma-ice/yelmo : git clone git@github.com:palma-ice/yelmo.git $YELMOROOT cd $YELMOROOT where $YELMOROOT is the installation directory. If you plan to make changes to the code, it is wise to check out a new branch: git checkout -b user-dev You should now be working on the branch user-dev .","title":"1. Get the code."},{"location":"getting-started/#2-create-the-system-specific-makefile","text":"To compile Yelmo, you need to generate a Makefile that is appropriate for your system. In the folder config , you need to specify a configuration file that defines the compiler and flags, including definition of the paths to the NetCDF and LIS libraries. You can use another file in the config folder as a template, e.g., cd config cp pik_ifort myhost_mycompiler then modify the file myhost_mycompiler to match your paths. Back in $YELMOROOT , you can then generate your Makefile with the provided python configuration script: cd $YELMOROOT python config.py config/myhost_mycompiler The result should be a Makefile in $YELMOROOT that is ready for use.","title":"2. Create the system-specific Makefile."},{"location":"getting-started/#3-compile-the-code","text":"Now you are ready to compile Yelmo as a static library: make clean # This step is very important to avoid errors!! make yelmo-static [debug=1] This will compile all of the Yelmo modules and libraries (as defined in config/Makefile_yelmo.mk ), and link them in a static library. All compiled files can be found in the folder libyelmo/ . Once the static library has been compiled, it can be used inside of external Fortran programs and modules via the statement use yelmo . To include/link yelmo-static during compilation of another program, its location must be defined: INC_YELMO = -I${YELMOROOT}/include LIB_YELMO = -L${YELMOROOT}/include -lyelmo Alternatively, several test programs exist in the folder tests/ to run Yelmo as a stand-alone ice sheet. For example, it's possible to run different EISMINT benchmarks, MISMIP benchmarks and the ISIMIP6 INITMIP simulation for Greenland, respectively: make benchmarks # compiles the program `libyelmo/bin/yelmo_benchmarks.x` make mismip # compiles the program `libyelmo/bin/yelmo_mismip.x` make initmip # compiles the program `libyelmo/bin/yelmo_initmip.x` The Makefile additionally allows you to specify debugging compiler flags with the option debug=1 , in case you need to debug the code (e.g., make benchmarks debug=1 ). Using this option, the code will run much slower, so this option is not recommended unless necessary.","title":"3. Compile the code."},{"location":"getting-started/#4-run-the-model","text":"Once an executable has been created, you can run the model. This can be achieved via the included Python job submission script run_yelmo.py . The following steps are carried out via the script: The output directory is created. The executable is copied to the output directory The relevant parameter files are copied to the output directory. Links to the input data paths ( input and ice_data ) are created in the output directory. (Note ice_data is typically linked to an external data repository, and is not necessary.) The executable is run from the output directory, either as a background process or it is submitted to the queue (the script currently supports qsubmit and sbatch commands). To run a benchmark simulation, for example, use the following command: python run_yelmo.py -r -e benchmarks output/test par/yelmo_EISMINT.nml where the option -r implies that the model should be run as a background process. If this is omitted, then the output directory will be populated, but no executable will be run, while -s instead will submit the simulation to cluster queue system instead of running in the background. The option -e lets you specify the executable. For some standard cases, shortcuts have been created: benchmarks = libyelmo/bin/yelmo_benchmarks.x mismip = libyelmo/bin/yemo_mismip.x initmip = libyelmo/bin/yelmo_initmip.x The last two mandatory arguments are always the output/run directory and the parameter file to be used for this simulation. In the case of the above simulation, the output directory is defined as output/test , where all model parameters (loaded from the file par/yelmo_EISMINT.nml ) and model output can be found.","title":"4. Run the model."},{"location":"parameters/","text":"Parameters Here important parameter choices pertinent to running Yelmo will be documented. Each section will outline a specific parameter or set of related parameters. The author of each section and the date last updated will apear in the heading, to maintain traceability in the documentation (since code usually changes over time). To do","title":"Parameters"},{"location":"parameters/#parameters","text":"Here important parameter choices pertinent to running Yelmo will be documented. Each section will outline a specific parameter or set of related parameters. The author of each section and the date last updated will apear in the heading, to maintain traceability in the documentation (since code usually changes over time).","title":"Parameters"},{"location":"parameters/#to-do","text":"","title":"To do"}]}