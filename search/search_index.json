{
    "docs": [
        {
            "location": "/", 
            "text": "Yelmo\n\n\nWelcome to Yelmo, an easy to use continental ice sheet model.\n\nYelmo\n is a 3D thermomechanical ice sheet model that\nsimulates continental scale ice sheets. It is a so-called hybrid\nmodel that solves both the Shallow Ice Approximation (SIA) for\nland-based ice driven by deformation, and the Shallow Shelf\nApproximation (SSA) for faster moving ice streams and ice shelves.\n\n\nIt has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain.\n\n\nHistory\n\n\nYelmo\n is based on the GRISLI code developed by Catherine Ritz\n(see Ritz et al., 1997), and subsequent modifications by coworkers in Grenoble and Paris until 2011.\nThe thermodynamic core (i.e., solvers) of \nYelmo\n has not been modified\nfrom GRISLI. Significant changes include all calculations related to\nboundary conditions (surface mass balance, topography, basal melt,\nsediments), as well as several helper modules to calculate the\nthermodynamics (basal dragging, deformation parameters).\n\n\n! **********************************************************************\n! GRISLI      Grenoble Ice Shelves-Land Ice\n! **********************************************************************\n! Ont participe a l'ecriture de ce modele :\n!\n!               Catherine Ritz                           (tout du long)\n!                   \ncatritz@lgge.obs.ujf-grenoble.fr\n\n!               Adeline Fabre                      (la partie Gremlins)\n!               Vincent Rommelaere         (ice shelves et ice streams)\n!               Christophe Dumas (debut f90,              (Antarctique)\n!               Vincent Peyaud      (portage HN,calving, front, hydrol)\n!               Cyril Mazauric                                  (AGRIF)\n!\n! From 2011 onwards as Yelmo :\n!               Alexander Robinson\n!               Jorge Alvarez-Solas\n!               Marisa Montoya\n!               Ilaria Tabone\n!               Javier Blasco\n! **********************************************************************\n\n\n\n\nDirectory structure\n\n\ndocs/\n    Model documentation.\ninput/\n    Location of any input data needed by the model.\n    The REMBOv2_data respository should be available here as:\n    `input/REMBOv2_data` which contains some useful boundary datasets.\nlibs/\n    Auxiliary libraries nesecessary for running the model.\nmaps/\n    Generated maps and grids.\noutput/\n    Default location for model output.\nsrc/\n    Source code for Yelmo.\n\n\n\nClasses and usage\n\n\nyelmo_class\n\n\nThe Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing variousparameters, variables or sets of module variables.\n\n\ntype yelmo_class\n\n    type(param_class)     :: par      ! Parameters\n    type(grid_class)      :: grid     ! Grid definition\n    type(ytopo_class)     :: topo     ! topography variables\n    type(yvel_class)      :: vel      ! velocity variables\n    type(yen_class)       :: en       ! energy (temp, enthalpy) variables\n\nend type\n\n\n\nLikewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography:\n\n\ntype ytopo_class\n\n    type(ytopo_param_class)   :: par        ! physical parameters\n    type(boundary_opt_class)  :: bnd, bnd0  ! boundary switches (bnd0 for equilibration)\n\n    ! All variables\n    type(ytopo_state_class) :: now\n\nend type\n\n\n\nSubmodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as so-called 'boundary switches' that define whether a variable should be calculated using the module are considered as a boundary (i.e., forcing) variable. Finally the class contains an additional type that defines the state of the variables in the module.\n\n\nExample model domain intialization\n\n\nThe yelmo_class is defined along with a set of subroutines that can be used to initialize, access and change the object (in object-oriented language, class methods).\n\n\nAssuming that a grid object has been defined previously (using the coordinates library), a yelmo_class object can be initialized using the following call:\n\n\ncall yelmo_init(yelmo_grl,\"Greenland\",grid=grid_grl)\n\n\n\nThis will initialize the object \nyelmo_grl\n with the domain name \"Greenland\" and the model domain will match the grid defined by the grid object \ngrid_grl\n (e.g., arrays will allocated to the size of the grid, etc.). Parameters will be initialized by first loading all of the default parameter sets from the Yelmo namelist file \nsrc/yelmo.nml\n. Next the program will look for a domain-specific namelist file that matches the name of the domain, in this case \nGreenland.nml\n. Any parameters that have been defined in this file will overwrite the default parameter values of the program.\n\n\nThere are only two additional public methods available for managing the yelmo_class object: \nyelmo_update\n and \nyelmo_end\n, which handle time-stepping of the model calculations and finalization (deallocation) of the object. \nyelmo_end\n is called at the end of the program or when a model domain variable should be deleted and the memory freed. \nyelmo_update\n is called in a time-stepping loop of a main program, e.g.:\n\n\ndo year = 1, 100\n    call yelmo_update(yelmo_grl,year=year)        \nend do\n\n\n\nThat's it! All options that manage the calculations to be performed have been defined in \nsrc/yelmo.nml\n and \nGreenland.nml\n, therefore no additional information needs to be passed except the time step.\n\n\nExchange of information between the yelmo_class object and other models, modules or even external datasets stored in files can be performed by direct access, or more rigorously by defining a subroutine in the Yelmo exchange module (\nsrc/yelmo_exchange.f90\n).\n\n\nGetting the code\n\n\nYelmo is managed using the version control software \ngit\n. To get started with a local working copy of the code, you need to (1) clone the repository to a local path, (2) create your own branch so that your changes do not conflict with the master branch and (3) synchronize your branch with the central repository so that your changes are also under version control.\n\n\ngit clone robinson@cluster.pik-potsdam.de:/iplex/01/tumble/robinson/repos/yelmo LOCAL_PATH\ngit checkout -b your_branch\ngit push -u origin your_branch\n\n\n\nNote use the command \ngit branch\n at any time to see which branches are available and which branch is currently checked out (marked by the asterisk).\n\n\nThat's it! You now have all of the Yelmo code in the local path \nLOCAL_PATH\n.\n\n\nBare (central) repository locations\n\n\nPIK repository location: \n/iplex/01/tumble/robinson/repos/yelmo\n\nUCM repository location: \n/home/fispalma25/repos/yelmo_mirror\n\n\nCompiling Yelmo programs\n\n\nYelmo uses a Makefile to manage program compilation. Currently one test program exists for Yelmo development: \ntest_yelmo.x\n. Compilation can be acheived via make:\n\n\nmake test_yelmo    : compiles the program test_yelmo.x (ice sheet development program)\nmake clean         : removes all compiled files\n\n\n\nBy default, the Makefile will choose gfortran as the compiler and use the \n-O3\n compiler options. To compile on the PIK cluster using ifort add \nifort=1\n to the end of the command, eg.:\n\n\nmake test_yelmo ifort=1\n\n\n\nLikewise to include debugging options, use \ndebug=1\n:\n\n\nmake test_yelmo debug=1\n\n\n\nIf compiled on the PIK cluster with ifort, the library paths given in the Makefile (mainly to find the netcdf libraries) should be correct and the programs should compile without any problems. For local compilation, typical Mac locations are currently specified that may need to be modified for other computers. To do so, find these lines in the Makefile:\n\n\nnetcdf_inc = /opt/local/include\nnetcdf_lib = /opt/local/lib\n\n\n\nRunning the programs\n\n\nYelmo is designed so that the source code is located in one place and each simulation produces output in a new directory. In this way, there is only one copy of the source code and compiled program, and one output directory for each program call.\n\n\nBy default, if no output directory is specified, the program sends output directly to the path \noutput\n and can be run from the command line:\n\n\n./test_yelmo.x\n\n\n\nOtherwise the output directory can be specified as a command-line argument. In this case, the output directory should already contain a copy of the namelist files for the domains to be simulated.\n\n\nmkdir output/simulation1\ncp Greenland.nml output/simulation1/\n./test_yelmo.x output/simulation1\n\n\n\nNote: In the near future, the automatic generation of output directories, as well as batch simulations and parameter changes will be handled using the python \njob\n script.\n\n\nParameter modification\n\n\nYelmo depends on a namelist file with default parameter values located in the \nsrc\n directory (\nsrc/yelmo.nml\n). This file should remain unchanged during production runs, it is only used to initially load all parameter values.\n\n\nNext, in the main directory, there should be one namelist file per modeled domain (e.g., \nGreenland.nml\n), with each group of parameters corresponding to each model component. The name of this namelist file corresponds to the name of the domain given in the code when the domain was initialized. As the program runs, it first loads parameters from the default namelist file, then it checks if any parameters should be overwritten from the domain-specific namelist file.\n\n\nThis two step procedure is convenient in that usually the default values do not change and can be stored for reference in the model component namelist file. Meanwhile in the domain-specific namelist file, only the parameters of interest that need to be modified for a given run need to be specified.\n\n\nLibraries\n\n\nYelmo relies on some external libraries (some of which have been built specifically for use with it), however the Yelmo repository is mostly self-contained. If the libraries are portable, like fortran modules, then they are stored in the \nlibs/\n subdirectory. The only external dependency is on the NetCDF libraries, which must be preinstalled on the system.\n\n\nBelow is a list of the libraries used in Yelmo:\n\n\nnml\n is a custom library for reading namelist parameters into a Fortran program. It has the same functionality as native nml reading, however it does not require the definition of a common block.\n\n\ncoordinates\n handles the definition of grids and points on user-specified coordinate systems. It has the ability to map between different coordinate systems, interpolation and oblique stereographic projection.\n\n\nsubset\n depends on the coordinates module and allows subsets of points to be generated from pre-defined grids. The subset of points can be of higher resolution than the original grid, and if so, mapping to and from the original grid is handled internally.\n\n\ninsol\n provides functions to calculate the daily insolation at any latitude for any time up to 5 Ma BP or 1 Ma AP (after present).\n\n\nsolvers\n provides some basic differential equation solvers.", 
            "title": "Home"
        }, 
        {
            "location": "/#yelmo", 
            "text": "Welcome to Yelmo, an easy to use continental ice sheet model. Yelmo  is a 3D thermomechanical ice sheet model that\nsimulates continental scale ice sheets. It is a so-called hybrid\nmodel that solves both the Shallow Ice Approximation (SIA) for\nland-based ice driven by deformation, and the Shallow Shelf\nApproximation (SSA) for faster moving ice streams and ice shelves.  It has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain.", 
            "title": "Yelmo"
        }, 
        {
            "location": "/#history", 
            "text": "Yelmo  is based on the GRISLI code developed by Catherine Ritz\n(see Ritz et al., 1997), and subsequent modifications by coworkers in Grenoble and Paris until 2011.\nThe thermodynamic core (i.e., solvers) of  Yelmo  has not been modified\nfrom GRISLI. Significant changes include all calculations related to\nboundary conditions (surface mass balance, topography, basal melt,\nsediments), as well as several helper modules to calculate the\nthermodynamics (basal dragging, deformation parameters).  ! **********************************************************************\n! GRISLI      Grenoble Ice Shelves-Land Ice\n! **********************************************************************\n! Ont participe a l'ecriture de ce modele :\n!\n!               Catherine Ritz                           (tout du long)\n!                    catritz@lgge.obs.ujf-grenoble.fr \n!               Adeline Fabre                      (la partie Gremlins)\n!               Vincent Rommelaere         (ice shelves et ice streams)\n!               Christophe Dumas (debut f90,              (Antarctique)\n!               Vincent Peyaud      (portage HN,calving, front, hydrol)\n!               Cyril Mazauric                                  (AGRIF)\n!\n! From 2011 onwards as Yelmo :\n!               Alexander Robinson\n!               Jorge Alvarez-Solas\n!               Marisa Montoya\n!               Ilaria Tabone\n!               Javier Blasco\n! **********************************************************************", 
            "title": "History"
        }, 
        {
            "location": "/#directory-structure", 
            "text": "docs/\n    Model documentation.\ninput/\n    Location of any input data needed by the model.\n    The REMBOv2_data respository should be available here as:\n    `input/REMBOv2_data` which contains some useful boundary datasets.\nlibs/\n    Auxiliary libraries nesecessary for running the model.\nmaps/\n    Generated maps and grids.\noutput/\n    Default location for model output.\nsrc/\n    Source code for Yelmo.", 
            "title": "Directory structure"
        }, 
        {
            "location": "/#classes-and-usage", 
            "text": "", 
            "title": "Classes and usage"
        }, 
        {
            "location": "/#yelmo_class", 
            "text": "The Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing variousparameters, variables or sets of module variables.  type yelmo_class\n\n    type(param_class)     :: par      ! Parameters\n    type(grid_class)      :: grid     ! Grid definition\n    type(ytopo_class)     :: topo     ! topography variables\n    type(yvel_class)      :: vel      ! velocity variables\n    type(yen_class)       :: en       ! energy (temp, enthalpy) variables\n\nend type  Likewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography:  type ytopo_class\n\n    type(ytopo_param_class)   :: par        ! physical parameters\n    type(boundary_opt_class)  :: bnd, bnd0  ! boundary switches (bnd0 for equilibration)\n\n    ! All variables\n    type(ytopo_state_class) :: now\n\nend type  Submodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as so-called 'boundary switches' that define whether a variable should be calculated using the module are considered as a boundary (i.e., forcing) variable. Finally the class contains an additional type that defines the state of the variables in the module.", 
            "title": "yelmo_class"
        }, 
        {
            "location": "/#example-model-domain-intialization", 
            "text": "The yelmo_class is defined along with a set of subroutines that can be used to initialize, access and change the object (in object-oriented language, class methods).  Assuming that a grid object has been defined previously (using the coordinates library), a yelmo_class object can be initialized using the following call:  call yelmo_init(yelmo_grl,\"Greenland\",grid=grid_grl)  This will initialize the object  yelmo_grl  with the domain name \"Greenland\" and the model domain will match the grid defined by the grid object  grid_grl  (e.g., arrays will allocated to the size of the grid, etc.). Parameters will be initialized by first loading all of the default parameter sets from the Yelmo namelist file  src/yelmo.nml . Next the program will look for a domain-specific namelist file that matches the name of the domain, in this case  Greenland.nml . Any parameters that have been defined in this file will overwrite the default parameter values of the program.  There are only two additional public methods available for managing the yelmo_class object:  yelmo_update  and  yelmo_end , which handle time-stepping of the model calculations and finalization (deallocation) of the object.  yelmo_end  is called at the end of the program or when a model domain variable should be deleted and the memory freed.  yelmo_update  is called in a time-stepping loop of a main program, e.g.:  do year = 1, 100\n    call yelmo_update(yelmo_grl,year=year)        \nend do  That's it! All options that manage the calculations to be performed have been defined in  src/yelmo.nml  and  Greenland.nml , therefore no additional information needs to be passed except the time step.  Exchange of information between the yelmo_class object and other models, modules or even external datasets stored in files can be performed by direct access, or more rigorously by defining a subroutine in the Yelmo exchange module ( src/yelmo_exchange.f90 ).", 
            "title": "Example model domain intialization"
        }, 
        {
            "location": "/#getting-the-code", 
            "text": "Yelmo is managed using the version control software  git . To get started with a local working copy of the code, you need to (1) clone the repository to a local path, (2) create your own branch so that your changes do not conflict with the master branch and (3) synchronize your branch with the central repository so that your changes are also under version control.  git clone robinson@cluster.pik-potsdam.de:/iplex/01/tumble/robinson/repos/yelmo LOCAL_PATH\ngit checkout -b your_branch\ngit push -u origin your_branch  Note use the command  git branch  at any time to see which branches are available and which branch is currently checked out (marked by the asterisk).  That's it! You now have all of the Yelmo code in the local path  LOCAL_PATH .", 
            "title": "Getting the code"
        }, 
        {
            "location": "/#bare-central-repository-locations", 
            "text": "PIK repository location:  /iplex/01/tumble/robinson/repos/yelmo \nUCM repository location:  /home/fispalma25/repos/yelmo_mirror", 
            "title": "Bare (central) repository locations"
        }, 
        {
            "location": "/#compiling-yelmo-programs", 
            "text": "Yelmo uses a Makefile to manage program compilation. Currently one test program exists for Yelmo development:  test_yelmo.x . Compilation can be acheived via make:  make test_yelmo    : compiles the program test_yelmo.x (ice sheet development program)\nmake clean         : removes all compiled files  By default, the Makefile will choose gfortran as the compiler and use the  -O3  compiler options. To compile on the PIK cluster using ifort add  ifort=1  to the end of the command, eg.:  make test_yelmo ifort=1  Likewise to include debugging options, use  debug=1 :  make test_yelmo debug=1  If compiled on the PIK cluster with ifort, the library paths given in the Makefile (mainly to find the netcdf libraries) should be correct and the programs should compile without any problems. For local compilation, typical Mac locations are currently specified that may need to be modified for other computers. To do so, find these lines in the Makefile:  netcdf_inc = /opt/local/include\nnetcdf_lib = /opt/local/lib", 
            "title": "Compiling Yelmo programs"
        }, 
        {
            "location": "/#running-the-programs", 
            "text": "Yelmo is designed so that the source code is located in one place and each simulation produces output in a new directory. In this way, there is only one copy of the source code and compiled program, and one output directory for each program call.  By default, if no output directory is specified, the program sends output directly to the path  output  and can be run from the command line:  ./test_yelmo.x  Otherwise the output directory can be specified as a command-line argument. In this case, the output directory should already contain a copy of the namelist files for the domains to be simulated.  mkdir output/simulation1\ncp Greenland.nml output/simulation1/\n./test_yelmo.x output/simulation1  Note: In the near future, the automatic generation of output directories, as well as batch simulations and parameter changes will be handled using the python  job  script.", 
            "title": "Running the programs"
        }, 
        {
            "location": "/#parameter-modification", 
            "text": "Yelmo depends on a namelist file with default parameter values located in the  src  directory ( src/yelmo.nml ). This file should remain unchanged during production runs, it is only used to initially load all parameter values.  Next, in the main directory, there should be one namelist file per modeled domain (e.g.,  Greenland.nml ), with each group of parameters corresponding to each model component. The name of this namelist file corresponds to the name of the domain given in the code when the domain was initialized. As the program runs, it first loads parameters from the default namelist file, then it checks if any parameters should be overwritten from the domain-specific namelist file.  This two step procedure is convenient in that usually the default values do not change and can be stored for reference in the model component namelist file. Meanwhile in the domain-specific namelist file, only the parameters of interest that need to be modified for a given run need to be specified.", 
            "title": "Parameter modification"
        }, 
        {
            "location": "/#libraries", 
            "text": "Yelmo relies on some external libraries (some of which have been built specifically for use with it), however the Yelmo repository is mostly self-contained. If the libraries are portable, like fortran modules, then they are stored in the  libs/  subdirectory. The only external dependency is on the NetCDF libraries, which must be preinstalled on the system.  Below is a list of the libraries used in Yelmo:  nml  is a custom library for reading namelist parameters into a Fortran program. It has the same functionality as native nml reading, however it does not require the definition of a common block.  coordinates  handles the definition of grids and points on user-specified coordinate systems. It has the ability to map between different coordinate systems, interpolation and oblique stereographic projection.  subset  depends on the coordinates module and allows subsets of points to be generated from pre-defined grids. The subset of points can be of higher resolution than the original grid, and if so, mapping to and from the original grid is handled internally.  insol  provides functions to calculate the daily insolation at any latitude for any time up to 5 Ma BP or 1 Ma AP (after present).  solvers  provides some basic differential equation solvers.", 
            "title": "Libraries"
        }, 
        {
            "location": "/getting-started/", 
            "text": "This file describes the basic steps needed to get \nYelmo\n\nrunning.\n\n\nDependencies\n\n\n\n\nNetCDF library (preferably version 4.0 or higher)\n\n\nLIS: \nLibrary of Iterative Solvers for Linear Systems\n\n\nCoordinates library\n\n\nPython 2.7.x (only needed for automation of configuration of Makefile\nand the use of the \nrun_yelmo.py\n script for job preparation and submission)\n\n\n\n\nOPTIONAL:\n\n\n\n\nAccess to the \nice_data\n repository of pre-processed\ninput data for the model on different domains (North, Antarctica,\nGreenland)\n\n\n\n\nDirectory structure\n\n\nconfig/\n    Location of the Makefile template and configuration files.\nextra_data/\n    An empty folder where user-specific input data can be stored.\ninput/\n    Location of any input time series and other data needed by the model.\nlibyelmo/\n    All compiled object files and binaries will be located here\n    after compilation (in bin/ and include/ directories).\nlibs/\n    Auxiliary included libraries necessary/useful for running the model.\noutput/\n    Default location for model output.\npar/\n    Folder containing the default parameter files for running Yelmo.\nsrc/\n    Source code for Yelmo.\n\n\n\n\nUsage\n\n\nYelmo\n is hosted in a git repository. Follow the steps below to\nobtain the code, compile it and run a test simulation.\n\n\n1. Get the code.\n\n\nClone the repository, check out a new branch and make sure it is linked 'upstream' to the same branch in the central repository:\n\n\ngit clone user@airara.fis.ucm.es:/palma/repos/yelmo.git yelmo\ngit checkout -b user-dev\ngit push -u origin user-dev\n\n\n\n\nYou should now be working on the branch \nuser-dev\n.\n\n\n2. Housekeeping.\n\n\n\n\nYou need to generate a symbolic link to the input (2D/3D/+) data folder that the model uses (typically the location of the \nice_data\n repository), e.g.,\n\n\n\n\nln -s PATH/TO/ice_data ice_data\n\n\n\n\n\n\nYou need to generate the Makefile that is appropriate for your system. In the folder config, you need to specify a configuration file with the name of your system that contains the paths to the \nNetCDF\n, \nLIS\n and \ncoordinates\n libraries. See others in the config folder for a template, e.g.,\n\n\n\n\ncd config\ncp eolo your_system\n\n\n\n\nthen modify the file \nyour_system\n to match your paths. This file should have the name that is output from your system when you run the bash command \nhostname\n. Back in the main \nyelmo\n directory, you can then generate your Makefile with the provided python configuration script:\n\n\ncd ..\npython config.py\n\n\n\n\n3. Compile the code.\n\n\nNow you are ready to compile the \nYelmo\n program you desire (eg, \nyelmo_eismint\n) :\n\n\nmake clean    *This step is very important to avoid errors!!\nmake yelmo_eismint [debug=1]\n\n\n\n\n(or other program \nyelmo_test\n, \nyelmo_mismip\n, \nyelmo_stommel\n or \nyelmo_optbeta\n). The \ndebug=1\n option allows you to compile with debugging compiler options enabled, in case you need to debug the code. Using this option, the code will run much slower, so this option is not recommended for real simulations.\n\n\n4. Run the model.\n\n\nOnce the executable has been created, you can run the model. This can be\nachieved via a Python job submission script \nrun_yelmo.py\n. The following steps\nare carried out via the script:\n\n\n\n\nThe output directory is created.\n\n\nThe parameter files are modified according to command-line options,\nthen saved in the output directory.\n\n\nThe executable is copied to the output directory, along with\nlinks to the input data paths (\ninput\n and \nice_data\n).\n\n\nThe executable is run from the output directory, either as a background process or it is submitted to the queue (currently supports \nqsubmit\n and \nsbatch\n commands).\n\n\n\n\nTO DO\n \nThe model output of each simulation will appear in the specified output directory. The above steps can also be run for a batch ensemble of simulations, which can also be automatically generated via \nrunner\n.\n\n\nTo run a test simulation \nyelmo_eismint.x\n, submitted to the queue (option \n-s\n), use the following command:\n\n\n./run_yelmo.py  -e yelmo_eismint.x -s -f -o output/test\n\n\n\n\nTO DO\n Or, you can change parameters at the command line:\n\n\n./run_yelmo.py -p yelmo_eismint.x -s -f -o output/test \\\ngroup=\npar1=0.0\n\n\n\n\n\nwhere \n\\\ngroup\n is the Namelist group that contains the parameter par1.\n\nTO DO\n Or, you can run an ensemble of simulations:\n\n\n./run_yelmo.py -p yelmo_eismint.x -s -f -a output/ens1 \\\ngroup=\npar1=0.0,0.5 par2=0,1,2\n\n\n\n\n\n*Note the change of \n-o\n to \n-a\n which means that sub-directories will be automatically generated for each simulation inside the chosen directory.\n\n\nMore information about running jobs can be found in the help:\n\n\n./run_yelmo.py -h", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#dependencies", 
            "text": "NetCDF library (preferably version 4.0 or higher)  LIS:  Library of Iterative Solvers for Linear Systems  Coordinates library  Python 2.7.x (only needed for automation of configuration of Makefile\nand the use of the  run_yelmo.py  script for job preparation and submission)   OPTIONAL:   Access to the  ice_data  repository of pre-processed\ninput data for the model on different domains (North, Antarctica,\nGreenland)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/getting-started/#directory-structure", 
            "text": "config/\n    Location of the Makefile template and configuration files.\nextra_data/\n    An empty folder where user-specific input data can be stored.\ninput/\n    Location of any input time series and other data needed by the model.\nlibyelmo/\n    All compiled object files and binaries will be located here\n    after compilation (in bin/ and include/ directories).\nlibs/\n    Auxiliary included libraries necessary/useful for running the model.\noutput/\n    Default location for model output.\npar/\n    Folder containing the default parameter files for running Yelmo.\nsrc/\n    Source code for Yelmo.", 
            "title": "Directory structure"
        }, 
        {
            "location": "/getting-started/#usage", 
            "text": "Yelmo  is hosted in a git repository. Follow the steps below to\nobtain the code, compile it and run a test simulation.", 
            "title": "Usage"
        }, 
        {
            "location": "/getting-started/#1-get-the-code", 
            "text": "Clone the repository, check out a new branch and make sure it is linked 'upstream' to the same branch in the central repository:  git clone user@airara.fis.ucm.es:/palma/repos/yelmo.git yelmo\ngit checkout -b user-dev\ngit push -u origin user-dev  You should now be working on the branch  user-dev .", 
            "title": "1. Get the code."
        }, 
        {
            "location": "/getting-started/#2-housekeeping", 
            "text": "You need to generate a symbolic link to the input (2D/3D/+) data folder that the model uses (typically the location of the  ice_data  repository), e.g.,   ln -s PATH/TO/ice_data ice_data   You need to generate the Makefile that is appropriate for your system. In the folder config, you need to specify a configuration file with the name of your system that contains the paths to the  NetCDF ,  LIS  and  coordinates  libraries. See others in the config folder for a template, e.g.,   cd config\ncp eolo your_system  then modify the file  your_system  to match your paths. This file should have the name that is output from your system when you run the bash command  hostname . Back in the main  yelmo  directory, you can then generate your Makefile with the provided python configuration script:  cd ..\npython config.py", 
            "title": "2. Housekeeping."
        }, 
        {
            "location": "/getting-started/#3-compile-the-code", 
            "text": "Now you are ready to compile the  Yelmo  program you desire (eg,  yelmo_eismint ) :  make clean    *This step is very important to avoid errors!!\nmake yelmo_eismint [debug=1]  (or other program  yelmo_test ,  yelmo_mismip ,  yelmo_stommel  or  yelmo_optbeta ). The  debug=1  option allows you to compile with debugging compiler options enabled, in case you need to debug the code. Using this option, the code will run much slower, so this option is not recommended for real simulations.", 
            "title": "3. Compile the code."
        }, 
        {
            "location": "/getting-started/#4-run-the-model", 
            "text": "Once the executable has been created, you can run the model. This can be\nachieved via a Python job submission script  run_yelmo.py . The following steps\nare carried out via the script:   The output directory is created.  The parameter files are modified according to command-line options,\nthen saved in the output directory.  The executable is copied to the output directory, along with\nlinks to the input data paths ( input  and  ice_data ).  The executable is run from the output directory, either as a background process or it is submitted to the queue (currently supports  qsubmit  and  sbatch  commands).   TO DO   The model output of each simulation will appear in the specified output directory. The above steps can also be run for a batch ensemble of simulations, which can also be automatically generated via  runner .  To run a test simulation  yelmo_eismint.x , submitted to the queue (option  -s ), use the following command:  ./run_yelmo.py  -e yelmo_eismint.x -s -f -o output/test  TO DO  Or, you can change parameters at the command line:  ./run_yelmo.py -p yelmo_eismint.x -s -f -o output/test \\ group= par1=0.0   where  \\ group  is the Namelist group that contains the parameter par1. TO DO  Or, you can run an ensemble of simulations:  ./run_yelmo.py -p yelmo_eismint.x -s -f -a output/ens1 \\ group= par1=0.0,0.5 par2=0,1,2   *Note the change of  -o  to  -a  which means that sub-directories will be automatically generated for each simulation inside the chosen directory.  More information about running jobs can be found in the help:  ./run_yelmo.py -h", 
            "title": "4. Run the model."
        }, 
        {
            "location": "/parameters/", 
            "text": "Parameters\n\n\nHere important parameter choices pertinent to running\n\nYelmo\n will be documented. Each section will\noutline a specific parameter or set of related parameters.\nThe author of each section and the date last updated\nwill apear in the heading, to maintain traceability\nin the documentation (since code usually changes over time).\n\n\ngvel_par\n\n\nAlexander Robinson, 2016-11-06\n\n\ngvel_par\n    mix_method  = 2      ! 0: None, 1: ssa+sia 2: ssa vel. fraction 3: Hwat fraction\n    ssa_vref    = 100    ! [m/a] Reference SSA velocity (denominator in tanh function)\n    Hmin        = 0      ! [m] Minimum water pressure to activate ssa\n    Hmax        = 50     ! [m] Maximum water pressure to reach full ssa conditions (mix_method=3)\n/\n\n\n\n\nThese parameters control the \nhybrid\n nature of \nYelmo\n.\n\nmix_method\n (formerly known as \ni_resolmeca\n) is a switch that\nspecifies how the SIA and SSA velocity solutions should be combined:\n\n\n\n\nmix_method=0\n: None, SIA and SSA domains are treated separately.\n\n\nmix_method=1\n: At any point where SSA is calculated, the SIA and SSA solutions are added.\n\n\nmix_method=2\n: SIA and SSA solutions are combined as a weighted average with the fraction of SSA determined by the SSA velocities (ie, method of Bueler and Brown, 2009).\n\n\nmix_method=3\n: SIA and SSA solutions are combined as a weighted average with the fraction of SSA determined by the basal water pressure.\n\n\n\n\nNote that the case \ni_resolmeca=1\n (ssa+sia, if ssa\nsia) no longer exists.\n\n\nssa_vref\n \n[m/a]\n is a scaling coefficient for \nmix_method=3\n. Default value is \nssa_vref=100\n.\n\n\nHmin\n and \nHmax\n are the minimum and maximum water pressure values, respectively, that define a linear transition between SIA and SSA (ie, below \nHmin\n velocity is defined solely by SIA, while above \nHmax\n, velocity is defined solely by SSA).\n\n\nNote that \nHmax\n is only used with \nmix_method=3\n, however \nHmin\n is also\nthe threshold for calculating the SSA solution. Typically \nHmin\n is set to a low value to avoid artificially constraining the SSA regions.\n\n\nbdrag_par\n\n\nAlexander Robinson, 2016-10-31\n\n\nbdrag_par\n    toblim            = 0.7e5  ! creo que no sirven\n    tobmax            = 1000.0 ! creo que no sirven\n    hmin_rock         = 0.0    ! North=400.0; South=50.0\n    hmax_rock         = 500.0\n    hmin_sed          = 1.0\n    beta_lim          = 1500.0    ! [Pa??]\n    beta_max          = 1000.0\n    beta_max_island   =  500.0\n    beta_min          =   10.0\n    beta_sia          = 1e5\n    cf_stream         = 20.0\n    cf_fac_sed        = 0.1\n    cf_fac_coast      = 0.01\n    cf_fac_island     = 0.01\n    stream_choice     = 0     ! 0: water-pressure; 1: stream-tracing\n    limit_friction    = FALSE ! True: the beta has boundaries \n SSA points are eliminated if beta is big enough\n                              ! False: beta is not limited and SSA can occupate whatever point for whatever beta\n\n/\n\n\n\n\nThe parameters in this section control the calculation of dragging in \nYelmo\n, in particular the dragging coefficient \n\u0392eta\n.\nFor now, most of the parameters are in fact either no longer used, or\nin the process of being phased out in favor of new approaches.\nHowever, the four \ncf_*\n parameters are critical:\n\n\n\n\ncf_stream\n \n[1e5 (m/a)^-1]\n This defines the base dragging coefficient, which applies for inland ice streams without sediments.\n\n\ncf_fac_sed\n The scaling factor relative to \ncf_stream\n for sediment-covered points, \u2208 (0,1).\n\n\ncf_fac_coast\n The scaling factor relative to \ncf_stream\n for coastal points, \u2208 (0,1).\n\n\ncf_fac_island\n The scaling factor relative to \ncf_stream\n for \"island\" points, \u2208 (0,1).\n\n\n\n\nNormally \ncf_fac_coast\n and \ncf_fac_island\n are close to zero.", 
            "title": "Parameters"
        }, 
        {
            "location": "/parameters/#parameters", 
            "text": "Here important parameter choices pertinent to running Yelmo  will be documented. Each section will\noutline a specific parameter or set of related parameters.\nThe author of each section and the date last updated\nwill apear in the heading, to maintain traceability\nin the documentation (since code usually changes over time).", 
            "title": "Parameters"
        }, 
        {
            "location": "/parameters/#gvel_par", 
            "text": "Alexander Robinson, 2016-11-06  gvel_par\n    mix_method  = 2      ! 0: None, 1: ssa+sia 2: ssa vel. fraction 3: Hwat fraction\n    ssa_vref    = 100    ! [m/a] Reference SSA velocity (denominator in tanh function)\n    Hmin        = 0      ! [m] Minimum water pressure to activate ssa\n    Hmax        = 50     ! [m] Maximum water pressure to reach full ssa conditions (mix_method=3)\n/  These parameters control the  hybrid  nature of  Yelmo . mix_method  (formerly known as  i_resolmeca ) is a switch that\nspecifies how the SIA and SSA velocity solutions should be combined:   mix_method=0 : None, SIA and SSA domains are treated separately.  mix_method=1 : At any point where SSA is calculated, the SIA and SSA solutions are added.  mix_method=2 : SIA and SSA solutions are combined as a weighted average with the fraction of SSA determined by the SSA velocities (ie, method of Bueler and Brown, 2009).  mix_method=3 : SIA and SSA solutions are combined as a weighted average with the fraction of SSA determined by the basal water pressure.   Note that the case  i_resolmeca=1  (ssa+sia, if ssa sia) no longer exists.  ssa_vref   [m/a]  is a scaling coefficient for  mix_method=3 . Default value is  ssa_vref=100 .  Hmin  and  Hmax  are the minimum and maximum water pressure values, respectively, that define a linear transition between SIA and SSA (ie, below  Hmin  velocity is defined solely by SIA, while above  Hmax , velocity is defined solely by SSA).  Note that  Hmax  is only used with  mix_method=3 , however  Hmin  is also\nthe threshold for calculating the SSA solution. Typically  Hmin  is set to a low value to avoid artificially constraining the SSA regions.", 
            "title": "gvel_par"
        }, 
        {
            "location": "/parameters/#bdrag_par", 
            "text": "Alexander Robinson, 2016-10-31  bdrag_par\n    toblim            = 0.7e5  ! creo que no sirven\n    tobmax            = 1000.0 ! creo que no sirven\n    hmin_rock         = 0.0    ! North=400.0; South=50.0\n    hmax_rock         = 500.0\n    hmin_sed          = 1.0\n    beta_lim          = 1500.0    ! [Pa??]\n    beta_max          = 1000.0\n    beta_max_island   =  500.0\n    beta_min          =   10.0\n    beta_sia          = 1e5\n    cf_stream         = 20.0\n    cf_fac_sed        = 0.1\n    cf_fac_coast      = 0.01\n    cf_fac_island     = 0.01\n    stream_choice     = 0     ! 0: water-pressure; 1: stream-tracing\n    limit_friction    = FALSE ! True: the beta has boundaries   SSA points are eliminated if beta is big enough\n                              ! False: beta is not limited and SSA can occupate whatever point for whatever beta\n\n/  The parameters in this section control the calculation of dragging in  Yelmo , in particular the dragging coefficient  \u0392eta .\nFor now, most of the parameters are in fact either no longer used, or\nin the process of being phased out in favor of new approaches.\nHowever, the four  cf_*  parameters are critical:   cf_stream   [1e5 (m/a)^-1]  This defines the base dragging coefficient, which applies for inland ice streams without sediments.  cf_fac_sed  The scaling factor relative to  cf_stream  for sediment-covered points, \u2208 (0,1).  cf_fac_coast  The scaling factor relative to  cf_stream  for coastal points, \u2208 (0,1).  cf_fac_island  The scaling factor relative to  cf_stream  for \"island\" points, \u2208 (0,1).   Normally  cf_fac_coast  and  cf_fac_island  are close to zero.", 
            "title": "bdrag_par"
        }
    ]
}