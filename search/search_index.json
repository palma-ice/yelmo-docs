{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yelmo Welcome to Yelmo , an easy to use continental ice sheet model. Yelmo is a 3D thermomechanical ice sheet model that simulates continental scale ice sheets. The ice dynamics can be treated via the Shallow Ice Approximation (SIA) for land-based ice driven by deformation, the Shallow Shelf Approximation (SSA) for faster moving ice streams and ice shelves and a hybrid configuration that hueristically combines the two approximations into one solution. Yelmo has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain. A description of Yelmo along with validation tests has been published here: Robinson et al., 2019... General model structure - classes and usage yelmo_class The Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing various parameters, variables or sets of module variables. type yelmo_class type(yelmo_param_class) :: par ! General domain parameters type(grid_class) :: grid ! Grid definition type(ytopo_class) :: tpo ! Topography variables type(ydyn_class) :: dyn ! Dynamics variables type(ymat_class) :: mat ! Material variables type(ytherm_class) :: thrm ! Thermodynamics variables type(ybound_class) :: bnd ! Boundary variables to drive model type(ydata_class) :: dta ! Data variables for comparison type(yregions_class) :: reg ! Regionally aggregated variables end type Likewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography: type ytopo_class type(ytopo_param_class) :: par ! Parameters type(ytopo_state_class) :: now ! Variables end type Submodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as all variables that define the state of the domain being modeled. Example model domain intialization The below code snippet shows an example of how to initialize an instance of Yelmo inside of a program, run the model forward in time and then terminate the instance. ! === Initialize ice sheet model ===== ! General initialization of yelmo constants (used globally, only once per program) call yelmo_global_init(path_const) ! Initialize Yelmo objects (multiple yelmo objects can be initialized if needed) ! In this case `yelmo1` is the Yelmo object to initialize and `path_par` is the ! path to the parameter file to load for the configuration information. call yelmo_init(yelmo1,filename=path_par) ! Next initialize the state of yelmo variables, first only the topography ! related variables (which can be useful for defining boundary conditions) call yelmo_init_state_1(yelmo1,path_par,time=time_init) ! === Load initial boundary conditions for current time and yelmo state ===== ! These variables can be loaded from a file, or passed from another ! component being simulated. Yelmo does not care about the source, ! it only needs all variables in the `bnd` class to be populated. ! ybound: z_bed, z_sl, H_sed, H_w, smb, T_srf, bmb_shlf, T_shlf, Q_geo yelmo1%bnd%z_bed = [2D array] yelmo1%bnd%z_sl = [2D array] yelmo1%bnd%H_sed = [2D array] yelmo1%bnd%H_w = [2D array] yelmo1%bnd%smb = [2D array] yelmo1%bnd%T_srf = [2D array] yelmo1%bnd%bmb_shlf = [2D array] yelmo1%bnd%T_shlf = [2D array] yelmo1%bnd%Q_geo = [2D array] ! Print summary of initial boundary conditions call yelmo_print_bound(yelmo1%bnd) ! Next, initialize remaining state variables (dyn,therm,mat) ! (in this case, initialize temps with robin method) call yelmo_init_state_2(yelmo1,path_par,time=time_init,thrm_method=\"robin\") ! Run yelmo for eg 100.0 years with constant boundary conditions and topo ! to equilibrate thermodynamics and dynamics ! (impose a constant, small dt=1yr to reduce possibility for instabilities) call yelmo_update_equil(yelmo1,time,time_tot=100.0,topo_fixed=.FALSE.,dt=1.0) ! == YELMO INITIALIZATION COMPLETE == ! Note: the above routines `yelmo_update_equil`, `yelmo_init_state_1` and ! `yelmo_init_state_2` are optional, if the user prefers another way ! to initialize the state variables. ! == Start time looping and run the model == ! Advance timesteps do n = 1, ntot ! Get current time time = time_init + n*dt ! Update the Yelmo ice sheet call yelmo_update(yelmo1,time) end do ! == Finalize Yelmo instance == call yelmo_end(yelmo1,time=time) That's it! See Getting started to see how to get the code, compile a test program and run simulations.","title":"Home"},{"location":"#yelmo","text":"Welcome to Yelmo , an easy to use continental ice sheet model. Yelmo is a 3D thermomechanical ice sheet model that simulates continental scale ice sheets. The ice dynamics can be treated via the Shallow Ice Approximation (SIA) for land-based ice driven by deformation, the Shallow Shelf Approximation (SSA) for faster moving ice streams and ice shelves and a hybrid configuration that hueristically combines the two approximations into one solution. Yelmo has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain. A description of Yelmo along with validation tests has been published here: Robinson et al., 2019...","title":"Yelmo"},{"location":"#general-model-structure-classes-and-usage","text":"","title":"General model structure - classes and usage"},{"location":"#yelmo_class","text":"The Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing various parameters, variables or sets of module variables. type yelmo_class type(yelmo_param_class) :: par ! General domain parameters type(grid_class) :: grid ! Grid definition type(ytopo_class) :: tpo ! Topography variables type(ydyn_class) :: dyn ! Dynamics variables type(ymat_class) :: mat ! Material variables type(ytherm_class) :: thrm ! Thermodynamics variables type(ybound_class) :: bnd ! Boundary variables to drive model type(ydata_class) :: dta ! Data variables for comparison type(yregions_class) :: reg ! Regionally aggregated variables end type Likewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography: type ytopo_class type(ytopo_param_class) :: par ! Parameters type(ytopo_state_class) :: now ! Variables end type Submodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as all variables that define the state of the domain being modeled.","title":"yelmo_class"},{"location":"#example-model-domain-intialization","text":"The below code snippet shows an example of how to initialize an instance of Yelmo inside of a program, run the model forward in time and then terminate the instance. ! === Initialize ice sheet model ===== ! General initialization of yelmo constants (used globally, only once per program) call yelmo_global_init(path_const) ! Initialize Yelmo objects (multiple yelmo objects can be initialized if needed) ! In this case `yelmo1` is the Yelmo object to initialize and `path_par` is the ! path to the parameter file to load for the configuration information. call yelmo_init(yelmo1,filename=path_par) ! Next initialize the state of yelmo variables, first only the topography ! related variables (which can be useful for defining boundary conditions) call yelmo_init_state_1(yelmo1,path_par,time=time_init) ! === Load initial boundary conditions for current time and yelmo state ===== ! These variables can be loaded from a file, or passed from another ! component being simulated. Yelmo does not care about the source, ! it only needs all variables in the `bnd` class to be populated. ! ybound: z_bed, z_sl, H_sed, H_w, smb, T_srf, bmb_shlf, T_shlf, Q_geo yelmo1%bnd%z_bed = [2D array] yelmo1%bnd%z_sl = [2D array] yelmo1%bnd%H_sed = [2D array] yelmo1%bnd%H_w = [2D array] yelmo1%bnd%smb = [2D array] yelmo1%bnd%T_srf = [2D array] yelmo1%bnd%bmb_shlf = [2D array] yelmo1%bnd%T_shlf = [2D array] yelmo1%bnd%Q_geo = [2D array] ! Print summary of initial boundary conditions call yelmo_print_bound(yelmo1%bnd) ! Next, initialize remaining state variables (dyn,therm,mat) ! (in this case, initialize temps with robin method) call yelmo_init_state_2(yelmo1,path_par,time=time_init,thrm_method=\"robin\") ! Run yelmo for eg 100.0 years with constant boundary conditions and topo ! to equilibrate thermodynamics and dynamics ! (impose a constant, small dt=1yr to reduce possibility for instabilities) call yelmo_update_equil(yelmo1,time,time_tot=100.0,topo_fixed=.FALSE.,dt=1.0) ! == YELMO INITIALIZATION COMPLETE == ! Note: the above routines `yelmo_update_equil`, `yelmo_init_state_1` and ! `yelmo_init_state_2` are optional, if the user prefers another way ! to initialize the state variables. ! == Start time looping and run the model == ! Advance timesteps do n = 1, ntot ! Get current time time = time_init + n*dt ! Update the Yelmo ice sheet call yelmo_update(yelmo1,time) end do ! == Finalize Yelmo instance == call yelmo_end(yelmo1,time=time) That's it! See Getting started to see how to get the code, compile a test program and run simulations.","title":"Example model domain intialization"},{"location":"dependencies/","text":"Yelmo is dependent on the following libraries: NetCDF Library of Iterative Solvers for Linear Systems Installing NetCDF (preferably version 4.0 or higher) The NetCDF library is typically available with different distributions (Linux, Mac, etc). Along with installing libnetcdf , it will be necessary to install the package libnetcdf-dev . Installing the NetCDF viewing program ncview is also recommended. If you want to install NetCDF from source, then you must install both the netcdf-c and subsequently netcdf-fortran libraries. The source code and installation instructions are available from the Unidata website: https://www.unidata.ucar.edu/software/netcdf/docs/getting_and_building_netcdf.html Installing LIS Download the LIS source: https://www.ssisc.org/lis/ Configure the package (where is the desired installation location), and install it in the location of your choice (below defined as $LISROOT ). Also, make sure to enable the Fortran90 interface: cd lis-2.0.18 ./configure --prefix=$LISROOT --enable-f90 make make install make install check Note: make sure to set the environment variables CC and FC , in order to set a specific compiler, for example for gcc/gfortran use the following configure command: CC=gcc FC=gfortran ./configure --prefix=$LISROOT --enable-f90 Add LIS path to the LD_LIBRARY_PATH in .bash_profile, .bashrc or .bash_aliases: # lis library paths LD_LIBRARY_PATH=$LISROOT/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH That' it. LIS should now be available to use with Yelmo.","title":"Dependencies"},{"location":"dependencies/#installing-netcdf-preferably-version-40-or-higher","text":"The NetCDF library is typically available with different distributions (Linux, Mac, etc). Along with installing libnetcdf , it will be necessary to install the package libnetcdf-dev . Installing the NetCDF viewing program ncview is also recommended. If you want to install NetCDF from source, then you must install both the netcdf-c and subsequently netcdf-fortran libraries. The source code and installation instructions are available from the Unidata website: https://www.unidata.ucar.edu/software/netcdf/docs/getting_and_building_netcdf.html","title":"Installing NetCDF (preferably version 4.0 or higher)"},{"location":"dependencies/#installing-lis","text":"Download the LIS source: https://www.ssisc.org/lis/ Configure the package (where is the desired installation location), and install it in the location of your choice (below defined as $LISROOT ). Also, make sure to enable the Fortran90 interface: cd lis-2.0.18 ./configure --prefix=$LISROOT --enable-f90 make make install make install check Note: make sure to set the environment variables CC and FC , in order to set a specific compiler, for example for gcc/gfortran use the following configure command: CC=gcc FC=gfortran ./configure --prefix=$LISROOT --enable-f90 Add LIS path to the LD_LIBRARY_PATH in .bash_profile, .bashrc or .bash_aliases: # lis library paths LD_LIBRARY_PATH=$LISROOT/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH That' it. LIS should now be available to use with Yelmo.","title":"Installing LIS"},{"location":"getting-started/","text":"This file describes the basic steps needed to get Yelmo running. Dependencies NetCDF library (preferably version 4.0 or higher) LIS: Library of Iterative Solvers for Linear Systems Coordinates library OPTIONAL: - Python 2.7.x or 3.x, which is only needed for automation of configuration of Makefile and the use of the run_yelmo.py script for job preparation and submission. - Python library runner , which extends the run_yelmo.py functionality to facilitate running ensembles of simulations. - Access to the ice_data repository of pre-processed input data for the model on different domains (North, Eurasia, Greenland, Antarctica) Directory structure config/ Configuration files for compilation on different systems. docs/ Model documentation. input/ Location of any input data needed by the model. libs/ Auxiliary libraries nesecessary for running the model. libyelmo/ Folder containing all compiled files in a standard way with lib/, include/ and bin/ folders. output/ Default location for model output. par/ Default parameter files that manage the model configuration. src/ Source code for Yelmo. tests/ Source code and analysis scripts for specific model benchmarks and tests. Usage Yelmo is hosted in a git repository. Follow the steps below to obtain the code, compile it and run a test simulation. 1. Get the code. Clone the repository, check out a new branch and make sure it is linked 'upstream' to the same branch in the central repository: git clone user@airara.fis.ucm.es:/palma/repos/yelmo.git yelmo git checkout -b user-dev git push -u origin user-dev You should now be working on the branch user-dev . 2. Housekeeping. You need to generate a symbolic link to the input (2D/3D/+) data folder that the model uses (typically the location of the ice_data repository), e.g., ln -s PATH/TO/ice_data ice_data You need to generate the Makefile that is appropriate for your system. In the folder config, you need to specify a configuration file with the name of your system that contains the paths to the NetCDF , LIS and coordinates libraries. See others in the config folder for a template, e.g., cd config cp eolo your_system then modify the file your_system to match your paths. This file should have the name that is output from your system when you run the bash command hostname . Back in the main yelmo directory, you can then generate your Makefile with the provided python configuration script: cd .. python config.py 3. Compile the code. Now you are ready to compile the Yelmo program you desire (eg, yelmo_benchmarks ) : make clean *This step is very important to avoid errors!! make yelmo_benchmarks [debug=1] (or other program yelmo_test , yelmo_mismip , yelmo_stommel or yelmo_optbeta ). The debug=1 option allows you to compile with debugging compiler options enabled, in case you need to debug the code. Using this option, the code will run much slower, so this option is not recommended for real simulations. 4. Run the model. Once the executable has been created, you can run the model. This can be achieved via a Python job submission script run_yelmo.py . The following steps are carried out via the script: The output directory is created. The executable is copied to the output directory The parameter files are copied to the output directory. Links to the input data paths ( input and ice_data ) are created in the output directory. The executable is run from the output directory, either as a background process or it is submitted to the queue (currently supports qsubmit and sbatch commands). To run a test simulation on a cluster using the executable yelmo_benchmarks.x , use the following command: ./run_yelmo.py -s -e benchmarks output/test par/yelmo_EISMINT.nml where -s implies submission to the cluster queue, and -e lets you specify the executable. For some standard cases, shortcuts have been created: benchmarks = libyelmo/bin/yelmo_benchmarks.x test = libyelmo/bin/yelmo_test.x mismip = libyelmo/bin/yemo_mismip.x The last two mandatory arguments are always the output/run directory and the parameter file to be used for this simulation. Additional powerful job submission functionality is available by using the Python runner tool. The job run command of the runner package allows you to change parameter values at the command line and perform large ensembles. For example, you can run an ensemble of two simulations as above but with different grid resolutions using: job run -f -o output/test -p eismint.dx=25.0,50.0 -- python run_yelmo.py -s -x -e benchmarks {} par/yelmo_EISMINT.nml where -f means execute the command without confirmation, -o is the parent ensemble directory, -p is the argument to allow you to list parameters to modify and eismint.dx=25.0,50.0 specifies that the parameter dx in the namelist group eismint should be given a value of 25.0 in one simulation and 50.0 in the second simulation. This command will modify the specified parameters found in the parameter file par_yelmo_EISMINT.nml and then run the simulation from the run directory output/test/{} where {} is the name of the directory corresponding to that parameter combination. Using the option -o means that the specific run directory name is simply the number of the simulation, so the run directory for the above command would be output/test/0 . Using the option -a means that the run directory will have a name corresponding to the parameter combination specified. Also note that for run_yelmo.py to work properly when called by job run , the additional option -x must be specified. The list of parameter choices corresponding to each directory can be found in the file: output/test/params.txt More information about running jobs can be found in the help of run_yelmo.py and runner : ./run_yelmo.py -h job -h job run -h Troubleshooting Runtime error: liblis.so.0 not found It may be necessary to export the LIS lib path to the linker, in order to avoid a runtime error. This can be achieved by including the following lines in the .bash_profile file: # lis library paths LD_LIBRARY_PATH=/home/fispalma25/apps/lis/lis/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH","title":"Getting started"},{"location":"getting-started/#dependencies","text":"NetCDF library (preferably version 4.0 or higher) LIS: Library of Iterative Solvers for Linear Systems Coordinates library OPTIONAL: - Python 2.7.x or 3.x, which is only needed for automation of configuration of Makefile and the use of the run_yelmo.py script for job preparation and submission. - Python library runner , which extends the run_yelmo.py functionality to facilitate running ensembles of simulations. - Access to the ice_data repository of pre-processed input data for the model on different domains (North, Eurasia, Greenland, Antarctica)","title":"Dependencies"},{"location":"getting-started/#directory-structure","text":"config/ Configuration files for compilation on different systems. docs/ Model documentation. input/ Location of any input data needed by the model. libs/ Auxiliary libraries nesecessary for running the model. libyelmo/ Folder containing all compiled files in a standard way with lib/, include/ and bin/ folders. output/ Default location for model output. par/ Default parameter files that manage the model configuration. src/ Source code for Yelmo. tests/ Source code and analysis scripts for specific model benchmarks and tests.","title":"Directory structure"},{"location":"getting-started/#usage","text":"Yelmo is hosted in a git repository. Follow the steps below to obtain the code, compile it and run a test simulation.","title":"Usage"},{"location":"getting-started/#1-get-the-code","text":"Clone the repository, check out a new branch and make sure it is linked 'upstream' to the same branch in the central repository: git clone user@airara.fis.ucm.es:/palma/repos/yelmo.git yelmo git checkout -b user-dev git push -u origin user-dev You should now be working on the branch user-dev .","title":"1. Get the code."},{"location":"getting-started/#2-housekeeping","text":"You need to generate a symbolic link to the input (2D/3D/+) data folder that the model uses (typically the location of the ice_data repository), e.g., ln -s PATH/TO/ice_data ice_data You need to generate the Makefile that is appropriate for your system. In the folder config, you need to specify a configuration file with the name of your system that contains the paths to the NetCDF , LIS and coordinates libraries. See others in the config folder for a template, e.g., cd config cp eolo your_system then modify the file your_system to match your paths. This file should have the name that is output from your system when you run the bash command hostname . Back in the main yelmo directory, you can then generate your Makefile with the provided python configuration script: cd .. python config.py","title":"2. Housekeeping."},{"location":"getting-started/#3-compile-the-code","text":"Now you are ready to compile the Yelmo program you desire (eg, yelmo_benchmarks ) : make clean *This step is very important to avoid errors!! make yelmo_benchmarks [debug=1] (or other program yelmo_test , yelmo_mismip , yelmo_stommel or yelmo_optbeta ). The debug=1 option allows you to compile with debugging compiler options enabled, in case you need to debug the code. Using this option, the code will run much slower, so this option is not recommended for real simulations.","title":"3. Compile the code."},{"location":"getting-started/#4-run-the-model","text":"Once the executable has been created, you can run the model. This can be achieved via a Python job submission script run_yelmo.py . The following steps are carried out via the script: The output directory is created. The executable is copied to the output directory The parameter files are copied to the output directory. Links to the input data paths ( input and ice_data ) are created in the output directory. The executable is run from the output directory, either as a background process or it is submitted to the queue (currently supports qsubmit and sbatch commands). To run a test simulation on a cluster using the executable yelmo_benchmarks.x , use the following command: ./run_yelmo.py -s -e benchmarks output/test par/yelmo_EISMINT.nml where -s implies submission to the cluster queue, and -e lets you specify the executable. For some standard cases, shortcuts have been created: benchmarks = libyelmo/bin/yelmo_benchmarks.x test = libyelmo/bin/yelmo_test.x mismip = libyelmo/bin/yemo_mismip.x The last two mandatory arguments are always the output/run directory and the parameter file to be used for this simulation. Additional powerful job submission functionality is available by using the Python runner tool. The job run command of the runner package allows you to change parameter values at the command line and perform large ensembles. For example, you can run an ensemble of two simulations as above but with different grid resolutions using: job run -f -o output/test -p eismint.dx=25.0,50.0 -- python run_yelmo.py -s -x -e benchmarks {} par/yelmo_EISMINT.nml where -f means execute the command without confirmation, -o is the parent ensemble directory, -p is the argument to allow you to list parameters to modify and eismint.dx=25.0,50.0 specifies that the parameter dx in the namelist group eismint should be given a value of 25.0 in one simulation and 50.0 in the second simulation. This command will modify the specified parameters found in the parameter file par_yelmo_EISMINT.nml and then run the simulation from the run directory output/test/{} where {} is the name of the directory corresponding to that parameter combination. Using the option -o means that the specific run directory name is simply the number of the simulation, so the run directory for the above command would be output/test/0 . Using the option -a means that the run directory will have a name corresponding to the parameter combination specified. Also note that for run_yelmo.py to work properly when called by job run , the additional option -x must be specified. The list of parameter choices corresponding to each directory can be found in the file: output/test/params.txt More information about running jobs can be found in the help of run_yelmo.py and runner : ./run_yelmo.py -h job -h job run -h","title":"4. Run the model."},{"location":"getting-started/#troubleshooting","text":"Runtime error: liblis.so.0 not found It may be necessary to export the LIS lib path to the linker, in order to avoid a runtime error. This can be achieved by including the following lines in the .bash_profile file: # lis library paths LD_LIBRARY_PATH=/home/fispalma25/apps/lis/lis/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH","title":"Troubleshooting"},{"location":"parameters/","text":"Parameters Here important parameter choices pertinent to running Yelmo will be documented. Each section will outline a specific parameter or set of related parameters. The author of each section and the date last updated will apear in the heading, to maintain traceability in the documentation (since code usually changes over time). To do","title":"Parameters"},{"location":"parameters/#parameters","text":"Here important parameter choices pertinent to running Yelmo will be documented. Each section will outline a specific parameter or set of related parameters. The author of each section and the date last updated will apear in the heading, to maintain traceability in the documentation (since code usually changes over time).","title":"Parameters"},{"location":"parameters/#to-do","text":"","title":"To do"}]}