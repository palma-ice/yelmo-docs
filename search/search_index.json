{
    "docs": [
        {
            "location": "/", 
            "text": "Yelmo\n\n\nWelcome to \nYelmo\n, an easy to use continental ice sheet model.\n\nYelmo\n is a 3D thermomechanical ice sheet model that\nsimulates continental scale ice sheets. The ice dynamics can \nbe treated via the Shallow Ice Approximation (SIA) for\nland-based ice driven by deformation, the Shallow Shelf\nApproximation (SSA) for faster moving ice streams and ice shelves and a hybrid configuration that hueristically combines the two approximations into one solution.\n\n\nYelmo\n has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain.\n\n\nA description of \nYelmo\n along with validation tests has been published here:\nRobinson et al., 2019...\n\n\nDirectory structure\n\n\nconfig/\n    Configuration files for compilation on different systems.\ndocs/\n    Model documentation.\ninput/\n    Location of any input data needed by the model.\nlibs/\n    Auxiliary libraries nesecessary for running the model.\nlibyelmo/\n    Folder containing all compiled files in a standard way with\n    lib/, include/ and bin/ folders.\noutput/\n    Default location for model output.\npar/ \n    Default parameter files that manage the model configuration.\nsrc/\n    Source code for Yelmo.\ntests/ \n    Source code and analysis scripts for specific model benchmarks and tests.\n\n\n\nClasses and usage\n\n\nyelmo_class\n\n\nThe Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing various parameters, variables or sets of module variables.\n\n\n    type yelmo_class\n        type(yelmo_param_class) :: par      ! General domain parameters\n        type(grid_class)        :: grid     ! Grid definition\n        type(ytopo_class)       :: tpo      ! Topography variables\n        type(ydyn_class)        :: dyn      ! Dynamics variables\n        type(ymat_class)        :: mat      ! Material variables\n        type(ytherm_class)      :: thrm     ! Thermodynamics variables\n        type(ybound_class)      :: bnd      ! Boundary variables to drive model\n        type(ydata_class)       :: dta      ! Data variables for comparison\n        type(yregions_class)    :: reg      ! Regionally aggregated variables  \n    end type\n\n\n\n\nLikewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography:\n\n\n    type ytopo_class\n\n        type(ytopo_param_class) :: par        ! Parameters\n        type(ytopo_state_class) :: now        ! Variables\n\n    end type\n\n\n\n\nSubmodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as all variables that define the state of the domain being modeled.\n\n\nExample model domain intialization\n\n\nThe below code snippet shows an example of how to initialize an instance of Yelmo \ninside of a program, run the model forward in time and then terminate the instance.\n\n\n    ! === Initialize ice sheet model =====\n\n    ! General initialization of yelmo constants (used globally, only once per program)\n\n    call yelmo_global_init(path_const)\n\n    ! Initialize Yelmo objects (multiple yelmo objects can be initialized if needed)\n    ! In this case `yelmo1` is the Yelmo object to initialize and `path_par` is the\n    ! path to the parameter file to load for the configuration information.\n\n    call yelmo_init(yelmo1,filename=path_par)\n\n    ! Next initialize the state of yelmo variables, first only the topography\n    ! related variables (which can be useful for defining boundary conditions)\n\n    call yelmo_init_state_1(yelmo1,path_par,time=time_init)\n\n    ! === Load initial boundary conditions for current time and yelmo state =====\n    ! These variables can be loaded from a file, or passed from another \n    ! component being simulated. Yelmo does not care about the source,\n    ! it only needs all variables in the `bnd` class to be populated.\n    ! ybound: z_bed, z_sl, H_sed, H_w, smb, T_srf, bmb_shlf, T_shlf, Q_geo\n\n    yelmo1%bnd%z_bed    = [2D array]\n    yelmo1%bnd%z_sl     = [2D array]\n    yelmo1%bnd%H_sed    = [2D array]\n    yelmo1%bnd%H_w      = [2D array]\n    yelmo1%bnd%smb      = [2D array]\n    yelmo1%bnd%T_srf    = [2D array]\n    yelmo1%bnd%bmb_shlf = [2D array]\n    yelmo1%bnd%T_shlf   = [2D array]\n    yelmo1%bnd%Q_geo    = [2D array]\n\n    ! Print summary of initial boundary conditions  \n    call yelmo_print_bound(yelmo1%bnd)\n\n\n    ! Next, initialize remaining state variables (dyn,therm,mat)\n    ! (in this case, initialize temps with robin method)\n\n    call yelmo_init_state_2(yelmo1,path_par,time=time_init,thrm_method=\nrobin\n)\n\n    ! Run yelmo for eg 100.0 years with constant boundary conditions and topo\n    ! to equilibrate thermodynamics and dynamics\n    ! (impose a constant, small dt=1yr to reduce possibility for instabilities)\n\n    call yelmo_update_equil(yelmo1,time,time_tot=100.0,topo_fixed=.FALSE.,dt=1.0)\n\n    ! == YELMO INITIALIZATION COMPLETE ==\n    ! Note: the above routines `yelmo_update_equil`, `yelmo_init_state_1` and\n    ! `yelmo_init_state_2` are optional, if the user prefers another way\n    ! to initialize the state variables.\n\n    ! == Start time looping and run the model == \n\n    ! Advance timesteps\n    do n = 1, ntot \n\n        ! Get current time \n        time = time_init + n*dt\n\n        ! Update the Yelmo ice sheet\n        call yelmo_update(yelmo1,time)\n\n\n    end do \n\n\n    ! == Finalize Yelmo instance == \n    call yelmo_end(yelmo1,time=time)\n\n\n\n\n\nThat's it! \n\n\nSee \nGetting started\n to see how to get the code, \ncompile a test program and run simulations.", 
            "title": "Home"
        }, 
        {
            "location": "/#yelmo", 
            "text": "Welcome to  Yelmo , an easy to use continental ice sheet model. Yelmo  is a 3D thermomechanical ice sheet model that\nsimulates continental scale ice sheets. The ice dynamics can \nbe treated via the Shallow Ice Approximation (SIA) for\nland-based ice driven by deformation, the Shallow Shelf\nApproximation (SSA) for faster moving ice streams and ice shelves and a hybrid configuration that hueristically combines the two approximations into one solution.  Yelmo  has been designed to operate as a stand-alone model or to be easily plugged in as a module in another program. The key to its flexibility is that no variables are defined globally and parameters are defined according to the domain being modeled. In this way, all variables and calculations are store in an object that entirely represents the model domain.  A description of  Yelmo  along with validation tests has been published here:\nRobinson et al., 2019...", 
            "title": "Yelmo"
        }, 
        {
            "location": "/#directory-structure", 
            "text": "config/\n    Configuration files for compilation on different systems.\ndocs/\n    Model documentation.\ninput/\n    Location of any input data needed by the model.\nlibs/\n    Auxiliary libraries nesecessary for running the model.\nlibyelmo/\n    Folder containing all compiled files in a standard way with\n    lib/, include/ and bin/ folders.\noutput/\n    Default location for model output.\npar/ \n    Default parameter files that manage the model configuration.\nsrc/\n    Source code for Yelmo.\ntests/ \n    Source code and analysis scripts for specific model benchmarks and tests.", 
            "title": "Directory structure"
        }, 
        {
            "location": "/#classes-and-usage", 
            "text": "", 
            "title": "Classes and usage"
        }, 
        {
            "location": "/#yelmo_class", 
            "text": "The Yelmo class defines all data related to a model domain, such as Greenland or Antarctica. As seen below in the yelmo_class defintion, the 'class' is simply a user-defined Fortran type that contains additional types representing various parameters, variables or sets of module variables.      type yelmo_class\n        type(yelmo_param_class) :: par      ! General domain parameters\n        type(grid_class)        :: grid     ! Grid definition\n        type(ytopo_class)       :: tpo      ! Topography variables\n        type(ydyn_class)        :: dyn      ! Dynamics variables\n        type(ymat_class)        :: mat      ! Material variables\n        type(ytherm_class)      :: thrm     ! Thermodynamics variables\n        type(ybound_class)      :: bnd      ! Boundary variables to drive model\n        type(ydata_class)       :: dta      ! Data variables for comparison\n        type(yregions_class)    :: reg      ! Regionally aggregated variables  \n    end type  Likewise the module variables are defined in a similar way, e.g. ytopo_class that defines variables and parameters associated with the topography:      type ytopo_class\n\n        type(ytopo_param_class) :: par        ! Parameters\n        type(ytopo_state_class) :: now        ! Variables\n\n    end type  Submodules such as ytopo_class include parameter definitions relevant to topography calculations, as well as all variables that define the state of the domain being modeled.", 
            "title": "yelmo_class"
        }, 
        {
            "location": "/#example-model-domain-intialization", 
            "text": "The below code snippet shows an example of how to initialize an instance of Yelmo \ninside of a program, run the model forward in time and then terminate the instance.      ! === Initialize ice sheet model =====\n\n    ! General initialization of yelmo constants (used globally, only once per program)\n\n    call yelmo_global_init(path_const)\n\n    ! Initialize Yelmo objects (multiple yelmo objects can be initialized if needed)\n    ! In this case `yelmo1` is the Yelmo object to initialize and `path_par` is the\n    ! path to the parameter file to load for the configuration information.\n\n    call yelmo_init(yelmo1,filename=path_par)\n\n    ! Next initialize the state of yelmo variables, first only the topography\n    ! related variables (which can be useful for defining boundary conditions)\n\n    call yelmo_init_state_1(yelmo1,path_par,time=time_init)\n\n    ! === Load initial boundary conditions for current time and yelmo state =====\n    ! These variables can be loaded from a file, or passed from another \n    ! component being simulated. Yelmo does not care about the source,\n    ! it only needs all variables in the `bnd` class to be populated.\n    ! ybound: z_bed, z_sl, H_sed, H_w, smb, T_srf, bmb_shlf, T_shlf, Q_geo\n\n    yelmo1%bnd%z_bed    = [2D array]\n    yelmo1%bnd%z_sl     = [2D array]\n    yelmo1%bnd%H_sed    = [2D array]\n    yelmo1%bnd%H_w      = [2D array]\n    yelmo1%bnd%smb      = [2D array]\n    yelmo1%bnd%T_srf    = [2D array]\n    yelmo1%bnd%bmb_shlf = [2D array]\n    yelmo1%bnd%T_shlf   = [2D array]\n    yelmo1%bnd%Q_geo    = [2D array]\n\n    ! Print summary of initial boundary conditions  \n    call yelmo_print_bound(yelmo1%bnd)\n\n\n    ! Next, initialize remaining state variables (dyn,therm,mat)\n    ! (in this case, initialize temps with robin method)\n\n    call yelmo_init_state_2(yelmo1,path_par,time=time_init,thrm_method= robin )\n\n    ! Run yelmo for eg 100.0 years with constant boundary conditions and topo\n    ! to equilibrate thermodynamics and dynamics\n    ! (impose a constant, small dt=1yr to reduce possibility for instabilities)\n\n    call yelmo_update_equil(yelmo1,time,time_tot=100.0,topo_fixed=.FALSE.,dt=1.0)\n\n    ! == YELMO INITIALIZATION COMPLETE ==\n    ! Note: the above routines `yelmo_update_equil`, `yelmo_init_state_1` and\n    ! `yelmo_init_state_2` are optional, if the user prefers another way\n    ! to initialize the state variables.\n\n    ! == Start time looping and run the model == \n\n    ! Advance timesteps\n    do n = 1, ntot \n\n        ! Get current time \n        time = time_init + n*dt\n\n        ! Update the Yelmo ice sheet\n        call yelmo_update(yelmo1,time)\n\n\n    end do \n\n\n    ! == Finalize Yelmo instance == \n    call yelmo_end(yelmo1,time=time)  That's it!   See  Getting started  to see how to get the code, \ncompile a test program and run simulations.", 
            "title": "Example model domain intialization"
        }, 
        {
            "location": "/getting-started/", 
            "text": "This file describes the basic steps needed to get \nYelmo\n\nrunning.\n\n\nDependencies\n\n\n\n\nNetCDF library (preferably version 4.0 or higher)\n\n\nLIS: \nLibrary of Iterative Solvers for Linear Systems\n\n\nCoordinates library\n\n\n\n\nOPTIONAL:\n- Python 2.7.x or 3.x, which is only needed for automation of configuration of Makefile\nand the use of the \nrun_yelmo.py\n script for job preparation and submission.\n- \nPython library \nrunner\n, which extends the \nrun_yelmo.py\n functionality to facilitate running ensembles of simulations.\n- Access to the \nice_data\n repository of pre-processed\ninput data for the model on different domains (North, Eurasia, Greenland, Antarctica)\n\n\nDirectory structure\n\n\nconfig/\n    Location of the Makefile template and configuration files.\nextra_data/\n    An empty folder where user-specific input data can be stored.\ninput/\n    Location of any input time series and other data needed by the model.\nlibyelmo/\n    All compiled object files and binaries will be located here\n    after compilation (in bin/ and include/ directories).\nlibs/\n    Auxiliary included libraries necessary/useful for running the model.\noutput/\n    Default location for model output.\npar/\n    Folder containing the default parameter files for running Yelmo.\nsrc/\n    Source code for Yelmo.\n\n\n\n\nUsage\n\n\nYelmo\n is hosted in a git repository. Follow the steps below to\nobtain the code, compile it and run a test simulation.\n\n\n1. Get the code.\n\n\nClone the repository, check out a new branch and make sure it is linked 'upstream' to the same branch in the central repository:\n\n\ngit clone user@airara.fis.ucm.es:/palma/repos/yelmo.git yelmo\ngit checkout -b user-dev\ngit push -u origin user-dev\n\n\n\n\nYou should now be working on the branch \nuser-dev\n.\n\n\n2. Housekeeping.\n\n\n\n\nYou need to generate a symbolic link to the input (2D/3D/+) data folder that the model uses (typically the location of the \nice_data\n repository), e.g.,\n\n\n\n\nln -s PATH/TO/ice_data ice_data\n\n\n\n\n\n\nYou need to generate the Makefile that is appropriate for your system. In the folder config, you need to specify a configuration file with the name of your system that contains the paths to the \nNetCDF\n, \nLIS\n and \ncoordinates\n libraries. See others in the config folder for a template, e.g.,\n\n\n\n\ncd config\ncp eolo your_system\n\n\n\n\nthen modify the file \nyour_system\n to match your paths. This file should have the name that is output from your system when you run the bash command \nhostname\n. Back in the main \nyelmo\n directory, you can then generate your Makefile with the provided python configuration script:\n\n\ncd ..\npython config.py\n\n\n\n\n3. Compile the code.\n\n\nNow you are ready to compile the \nYelmo\n program you desire (eg, \nyelmo_benchmarks\n) :\n\n\nmake clean    *This step is very important to avoid errors!!\nmake yelmo_benchmarks [debug=1]\n\n\n\n\n(or other program \nyelmo_test\n, \nyelmo_mismip\n, \nyelmo_stommel\n or \nyelmo_optbeta\n). The \ndebug=1\n option allows you to compile with debugging compiler options enabled, in case you need to debug the code. Using this option, the code will run much slower, so this option is not recommended for real simulations.\n\n\n4. Run the model.\n\n\nOnce the executable has been created, you can run the model. This can be\nachieved via a Python job submission script \nrun_yelmo.py\n. The following steps\nare carried out via the script:\n\n\n\n\nThe output directory is created.\n\n\nThe executable is copied to the output directory\n\n\nThe parameter files are copied to the output directory.\n\n\nLinks to the input data paths (\ninput\n and \nice_data\n) are created in the output directory.\n\n\nThe executable is run from the output directory, either as a background process or it is submitted to the queue (currently supports \nqsubmit\n and \nsbatch\n commands).\n\n\n\n\nTo run a test simulation on a cluster using the executable \nyelmo_benchmarks.x\n, use the following command:\n\n\n./run_yelmo.py -s -e benchmarks output/test par/yelmo_EISMINT.nml \n\n\n\n\nwhere \n-s\n implies submission to the cluster queue, and \n-e\n lets you specify the executable. For some standard cases, shortcuts have been created:\n\n\nbenchmarks = libyelmo/bin/yelmo_benchmarks.x \ntest       = libyelmo/bin/yelmo_test.x \nmismip     = libyelmo/bin/yemo_mismip.x \n\n\n\n\nThe last two mandatory arguments are always the output/run directory and the parameter file to be used for this simulation. \n\n\nAdditional powerful job submission functionality is available by using the Python \nrunner\n tool. The \njob run\n command of the \nrunner\n package allows you to change parameter values at the command line and perform large ensembles. For example, you can run an ensemble of two simulations as above but with different grid resolutions using:\n\n\njob run -f -o output/test -p eismint.dx=25.0,50.0 -- python run_yelmo.py -s -x -e benchmarks {} par/yelmo_EISMINT.nml\n\n\n\n\nwhere \n-f\n means execute the command without confirmation, \n-o\n is the parent ensemble directory, \n-p\n is the argument to allow you to list parameters to modify and \neismint.dx=25.0,50.0\n specifies that the parameter \ndx\n in the namelist group \neismint\n should be given a value of \n25.0\n in one simulation and \n50.0\n in the second simulation. This command will modify the specified parameters found in the parameter file \npar_yelmo_EISMINT.nml\n and then run the simulation from the run directory \noutput/test/{}\n where \n{}\n is the name of the directory corresponding to that parameter combination. Using the option \n-o\n means that the specific run directory name is simply the number of the simulation, so the run directory for the above command would be \noutput/test/0\n. Using the option \n-a\n means that the run directory will have a name corresponding to the parameter combination specified. Also note that for \nrun_yelmo.py\n to work properly when called by \njob run\n, the additional option \n-x\n must be specified.\n\n\nThe list of parameter choices corresponding to each directory can be found in the file:\n\n\noutput/test/params.txt\n\n\n\n\nMore information about running jobs can be found in the help of \nrun_yelmo.py\n and \nrunner\n:\n\n\n./run_yelmo.py -h\njob -h \njob run -h \n\n\n\n\nTroubleshooting\n\n\nRuntime error: liblis.so.0 not found\n\nIt may be necessary to export the LIS lib path to the linker, in order to avoid a runtime error. This can be achieved by including the following lines in the \n.bash_profile\n file:\n\n\n# lis library paths \nLD_LIBRARY_PATH=/home/fispalma25/apps/lis/lis/lib:$LD_LIBRARY_PATH\nexport LD_LIBRARY_PATH", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#dependencies", 
            "text": "NetCDF library (preferably version 4.0 or higher)  LIS:  Library of Iterative Solvers for Linear Systems  Coordinates library   OPTIONAL:\n- Python 2.7.x or 3.x, which is only needed for automation of configuration of Makefile\nand the use of the  run_yelmo.py  script for job preparation and submission.\n-  Python library  runner , which extends the  run_yelmo.py  functionality to facilitate running ensembles of simulations.\n- Access to the  ice_data  repository of pre-processed\ninput data for the model on different domains (North, Eurasia, Greenland, Antarctica)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/getting-started/#directory-structure", 
            "text": "config/\n    Location of the Makefile template and configuration files.\nextra_data/\n    An empty folder where user-specific input data can be stored.\ninput/\n    Location of any input time series and other data needed by the model.\nlibyelmo/\n    All compiled object files and binaries will be located here\n    after compilation (in bin/ and include/ directories).\nlibs/\n    Auxiliary included libraries necessary/useful for running the model.\noutput/\n    Default location for model output.\npar/\n    Folder containing the default parameter files for running Yelmo.\nsrc/\n    Source code for Yelmo.", 
            "title": "Directory structure"
        }, 
        {
            "location": "/getting-started/#usage", 
            "text": "Yelmo  is hosted in a git repository. Follow the steps below to\nobtain the code, compile it and run a test simulation.", 
            "title": "Usage"
        }, 
        {
            "location": "/getting-started/#1-get-the-code", 
            "text": "Clone the repository, check out a new branch and make sure it is linked 'upstream' to the same branch in the central repository:  git clone user@airara.fis.ucm.es:/palma/repos/yelmo.git yelmo\ngit checkout -b user-dev\ngit push -u origin user-dev  You should now be working on the branch  user-dev .", 
            "title": "1. Get the code."
        }, 
        {
            "location": "/getting-started/#2-housekeeping", 
            "text": "You need to generate a symbolic link to the input (2D/3D/+) data folder that the model uses (typically the location of the  ice_data  repository), e.g.,   ln -s PATH/TO/ice_data ice_data   You need to generate the Makefile that is appropriate for your system. In the folder config, you need to specify a configuration file with the name of your system that contains the paths to the  NetCDF ,  LIS  and  coordinates  libraries. See others in the config folder for a template, e.g.,   cd config\ncp eolo your_system  then modify the file  your_system  to match your paths. This file should have the name that is output from your system when you run the bash command  hostname . Back in the main  yelmo  directory, you can then generate your Makefile with the provided python configuration script:  cd ..\npython config.py", 
            "title": "2. Housekeeping."
        }, 
        {
            "location": "/getting-started/#3-compile-the-code", 
            "text": "Now you are ready to compile the  Yelmo  program you desire (eg,  yelmo_benchmarks ) :  make clean    *This step is very important to avoid errors!!\nmake yelmo_benchmarks [debug=1]  (or other program  yelmo_test ,  yelmo_mismip ,  yelmo_stommel  or  yelmo_optbeta ). The  debug=1  option allows you to compile with debugging compiler options enabled, in case you need to debug the code. Using this option, the code will run much slower, so this option is not recommended for real simulations.", 
            "title": "3. Compile the code."
        }, 
        {
            "location": "/getting-started/#4-run-the-model", 
            "text": "Once the executable has been created, you can run the model. This can be\nachieved via a Python job submission script  run_yelmo.py . The following steps\nare carried out via the script:   The output directory is created.  The executable is copied to the output directory  The parameter files are copied to the output directory.  Links to the input data paths ( input  and  ice_data ) are created in the output directory.  The executable is run from the output directory, either as a background process or it is submitted to the queue (currently supports  qsubmit  and  sbatch  commands).   To run a test simulation on a cluster using the executable  yelmo_benchmarks.x , use the following command:  ./run_yelmo.py -s -e benchmarks output/test par/yelmo_EISMINT.nml   where  -s  implies submission to the cluster queue, and  -e  lets you specify the executable. For some standard cases, shortcuts have been created:  benchmarks = libyelmo/bin/yelmo_benchmarks.x \ntest       = libyelmo/bin/yelmo_test.x \nmismip     = libyelmo/bin/yemo_mismip.x   The last two mandatory arguments are always the output/run directory and the parameter file to be used for this simulation.   Additional powerful job submission functionality is available by using the Python  runner  tool. The  job run  command of the  runner  package allows you to change parameter values at the command line and perform large ensembles. For example, you can run an ensemble of two simulations as above but with different grid resolutions using:  job run -f -o output/test -p eismint.dx=25.0,50.0 -- python run_yelmo.py -s -x -e benchmarks {} par/yelmo_EISMINT.nml  where  -f  means execute the command without confirmation,  -o  is the parent ensemble directory,  -p  is the argument to allow you to list parameters to modify and  eismint.dx=25.0,50.0  specifies that the parameter  dx  in the namelist group  eismint  should be given a value of  25.0  in one simulation and  50.0  in the second simulation. This command will modify the specified parameters found in the parameter file  par_yelmo_EISMINT.nml  and then run the simulation from the run directory  output/test/{}  where  {}  is the name of the directory corresponding to that parameter combination. Using the option  -o  means that the specific run directory name is simply the number of the simulation, so the run directory for the above command would be  output/test/0 . Using the option  -a  means that the run directory will have a name corresponding to the parameter combination specified. Also note that for  run_yelmo.py  to work properly when called by  job run , the additional option  -x  must be specified.  The list of parameter choices corresponding to each directory can be found in the file:  output/test/params.txt  More information about running jobs can be found in the help of  run_yelmo.py  and  runner :  ./run_yelmo.py -h\njob -h \njob run -h", 
            "title": "4. Run the model."
        }, 
        {
            "location": "/getting-started/#troubleshooting", 
            "text": "Runtime error: liblis.so.0 not found \nIt may be necessary to export the LIS lib path to the linker, in order to avoid a runtime error. This can be achieved by including the following lines in the  .bash_profile  file:  # lis library paths \nLD_LIBRARY_PATH=/home/fispalma25/apps/lis/lis/lib:$LD_LIBRARY_PATH\nexport LD_LIBRARY_PATH", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/parameters/", 
            "text": "Parameters\n\n\nHere important parameter choices pertinent to running\n\nYelmo\n will be documented. Each section will\noutline a specific parameter or set of related parameters.\nThe author of each section and the date last updated\nwill apear in the heading, to maintain traceability\nin the documentation (since code usually changes over time).\n\n\nTo do", 
            "title": "Parameters"
        }, 
        {
            "location": "/parameters/#parameters", 
            "text": "Here important parameter choices pertinent to running Yelmo  will be documented. Each section will\noutline a specific parameter or set of related parameters.\nThe author of each section and the date last updated\nwill apear in the heading, to maintain traceability\nin the documentation (since code usually changes over time).", 
            "title": "Parameters"
        }, 
        {
            "location": "/parameters/#to-do", 
            "text": "", 
            "title": "To do"
        }
    ]
}